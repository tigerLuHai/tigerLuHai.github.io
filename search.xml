<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>稳定排序与非稳定排序的应用场景</title>
      <link href="/2020/01/22/wen-ding-pai-xu-yu-fei-wen-ding-pai-xu-de-ying-yong-chang-jing/"/>
      <url>/2020/01/22/wen-ding-pai-xu-yu-fei-wen-ding-pai-xu-de-ying-yong-chang-jing/</url>
      
        <content type="html"><![CDATA[<h3 id="稳定非稳定如何界定"><a href="#稳定非稳定如何界定" class="headerlink" title="稳定非稳定如何界定"></a>稳定非稳定如何界定</h3><p><img src="/2020/01/22/wen-ding-pai-xu-yu-fei-wen-ding-pai-xu-de-ying-yong-chang-jing/D:%5CMyBlot%5Cbolt%5Csource_posts%5C%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F%E4%B8%8E%E9%9D%9E%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%5Cstable1.png" alt="img"></p><p>原始数据，a2和a4的位置都是3。对于稳定排序来说，排序后的序列，a2一定还是在a4前面。但是对于非稳定排序来说，就不一定了，可能排完序之后，a4反而在a2的前面了。</p><p>哪些常用算法是稳定的，哪些是不稳定的呢？</p><p>冒泡和归并排序是稳定的，快排和选择排序是非稳定的。</p><p><strong>思考</strong>：既然最后都是有序序列，为什么还要分稳定和非稳定的排序呢？</p><h3 id="为什么要分稳定和非稳定呢？"><a href="#为什么要分稳定和非稳定呢？" class="headerlink" title="为什么要分稳定和非稳定呢？"></a>为什么要分稳定和非稳定呢？</h3><p>看一个典型的场景：每次考试完成后，都会按照分数进行排序。分高的自然就是第一名。分数相同的同学怎么办呢？那就是按照上次的分数来分高低。上次分高的排在前面。</p><p>这个时候就应该用稳定排序，在上次排好序的序列上，再针对这次的分数进行排序。稳定排序的结果能保证这次相同分数的人，上次分高的在前面。</p><p>再比如我们熟知的基数排序与计数排序,当对最后一位进行计数排序后,当倒数第二位的数字相同时,必须保证第一轮技术排序排在前面的经过重排后还在前面。这时就需要计数排序是稳定的。</p><p>其实就是有两个排序关键字的时候，稳定排序可以让第一个关键字排序的结果服务于第二个关键字排序中数值相等的那些数。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP与HTTPS原理</title>
      <link href="/2020/01/21/http-yu-https-yuan-li/"/>
      <url>/2020/01/21/http-yu-https-yuan-li/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://augustrush8.com/post/http-principle.html#%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener">概述</a></li><li>传输流程<ul><li><a href="https://augustrush8.com/post/http-principle.html#%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90" target="_blank" rel="noopener">地址解析</a></li><li><a href="https://augustrush8.com/post/http-principle.html#%E5%B0%81%E8%A3%85-http-%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E5%8C%85" target="_blank" rel="noopener">封装 HTTP 请求数据包</a></li><li><a href="https://augustrush8.com/post/http-principle.html#%E5%B0%81%E8%A3%85%E6%88%90-tcp-%E5%8C%85%E5%B9%B6%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener">封装成 TCP 包并建立连接</a></li><li><a href="https://augustrush8.com/post/http-principle.html#%E5%AE%A2%E6%88%B7%E6%9C%BA%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">客户机发送请求命令</a></li><li><a href="https://augustrush8.com/post/http-principle.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94" target="_blank" rel="noopener">服务器响应</a></li><li><a href="https://augustrush8.com/post/http-principle.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%B3%E9%97%AD-tcp-%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener">服务器关闭 TCP 连接</a></li><li><a href="https://augustrush8.com/post/http-principle.html#http%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81" target="_blank" rel="noopener">HTTP响应状态</a></li></ul></li><li><a href="https://augustrush8.com/post/http-principle.html#%E5%B0%8F%E6%8F%92%E6%9B%B2301%E5%92%8C302%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">小插曲：301和302有啥区别</a></li><li>HTTPS<ul><li><a href="https://augustrush8.com/post/http-principle.html#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E8%8E%B7%E5%8F%96%E8%AF%81%E4%B9%A6" target="_blank" rel="noopener">建立连接获取证书</a></li><li><a href="https://augustrush8.com/post/http-principle.html#%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81" target="_blank" rel="noopener">证书验证</a></li><li><a href="https://augustrush8.com/post/http-principle.html#%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%92%8C%E4%BC%A0%E8%BE%93" target="_blank" rel="noopener">数据加密和传输</a></li></ul></li></ul><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>HTTP 是一个无状态的协议。无状态是指客户机（Web 浏览器）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP 遵循请求(Request)/应答(Response)模型。客户机（浏览器）向服务器发送请求，服务器处理请求并返回适当的应答。所有 HTTP 连接都被构造成一套请求和应答。</p><h3 id="传输流程"><a href="#传输流程" class="headerlink" title="传输流程"></a>传输流程</h3><h4 id="地址解析"><a href="#地址解析" class="headerlink" title="地址解析"></a>地址解析</h4><p>如用客户端浏览器请求这个页面： <a href="http://localhost.com:8080/index.htm" target="_blank" rel="noopener">http://localhost.com:8080/index.htm</a> 从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：</p><ul><li>协议名： http</li><li>主机名： localhost.com</li><li>端口： 8080</li><li>对象路径： /index.htm</li></ul><p>在这一步，需要域名系统 DNS 解析域名 localhost.com,得主机的 IP 地址。</p><h4 id="封装-HTTP-请求数据包"><a href="#封装-HTTP-请求数据包" class="headerlink" title="封装 HTTP 请求数据包"></a>封装 HTTP 请求数据包</h4><p>把以上部分结合本机自己的信息，封装成一个 HTTP 请求数据包</p><h4 id="封装成-TCP-包并建立连接"><a href="#封装成-TCP-包并建立连接" class="headerlink" title="封装成 TCP 包并建立连接"></a>封装成 TCP 包并建立连接</h4><p>封装成 TCP 包，建立 TCP 连接（TCP 的三次握手）</p><h4 id="客户机发送请求命令"><a href="#客户机发送请求命令" class="headerlink" title="客户机发送请求命令"></a>客户机发送请求命令</h4><p>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和可能的内容。</p><h4 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h4><p>服务器接到请求后，给予相应的响应信息， 其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</p><h4 id="服务器关闭-TCP-连接"><a href="#服务器关闭-TCP-连接" class="headerlink" title="服务器关闭 TCP 连接"></a>服务器关闭 TCP 连接</h4><p>服务器关闭 TCP 连接： 一般情况下，一旦 Web 服务器向浏览器发送了请求数据，它就要关闭 TCP 连接，然后如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive， TCP 连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p><p><img src="HTTP%E4%B8%8EHTTPS%E5%8E%9F%E7%90%86%5Chttp1.png" alt="img"></p><h4 id="HTTP响应状态"><a href="#HTTP响应状态" class="headerlink" title="HTTP响应状态"></a>HTTP响应状态</h4><ul><li>1XX</li></ul><p><img src="HTTP%E4%B8%8EHTTPS%E5%8E%9F%E7%90%86%5Chttp2.png" alt="img"></p><ul><li>2XX</li></ul><p><img src="HTTP%E4%B8%8EHTTPS%E5%8E%9F%E7%90%86%5Chttp3.png" alt="img"></p><ul><li>3XX</li></ul><p><img src="HTTP%E4%B8%8EHTTPS%E5%8E%9F%E7%90%86%5Chttp4.png" alt="img"></p><ul><li>4XX</li></ul><p><img src="HTTP%E4%B8%8EHTTPS%E5%8E%9F%E7%90%86%5Chttp5.png" alt="img"></p><ul><li>5XX</li></ul><p><img src="HTTP%E4%B8%8EHTTPS%E5%8E%9F%E7%90%86%5Chttp6.png" alt="img"></p><h3 id="小插曲：301和302有啥区别"><a href="#小插曲：301和302有啥区别" class="headerlink" title="小插曲：301和302有啥区别"></a>小插曲：301和302有啥区别</h3><p>官方说法：</p><blockquote><p>301，302 都是HTTP状态的编码，都代表着某个URL发生了转移，不同之处在于： 301 redirect: 301 代表永久性转移(Permanently Moved)。 302 redirect: 302 代表暂时性转移(Temporarily Moved )。</p></blockquote><p>现实中的差异：</p><ul><li><strong>对于用户</strong>：</li></ul><p>301，302对用户来说没有区别，他们看到效果只是一个跳转，浏览器中旧的URL变成了新的URL。页面跳到了这个新的url指向的地方。</p><ul><li><strong>对于引擎及站长</strong>：</li></ul><ol><li>302：302转向可能会有URL规范化及网址劫持的问题。可能被搜索引擎判为可疑转向，甚至认为是作弊</li></ol><p><strong>网址劫持</strong>： 302重定向和网址劫持（URL hijacking）有什么关系呢？这要从搜索引擎如何处理302转向说起。从定义来说，从网址A做一个302重定向到网址B时，主机服务器的隐含意思是网址A随时有可能改主意，重新显示本身的内容或转向其他的地方。大部分的搜索引擎在大部分情况下，当收到302重定向时，一般只要去抓取目标网址就可以了，也就是说网址B。 实际上如果搜索引擎在遇到302转向时，百分之百的都抓取目标网址B的话，就不用担心网址URL劫持了。问题就在于，有的时候搜索引擎，尤其是Google，并不能总是抓取目标网址。为什么呢？比如说，有的时候A网址很短，但是它做了一个302重定向到B网址，而B网址是一个很长的乱七八糟的URL网址，甚至还有可能包含一些问号之类的参数。很自然的，A网址更加用户友好，而B网址既难看，又不用户友好。这时Google很有可能会仍然显示网址A。</p><p>由于搜索引擎排名算法只是程序而不是人，在遇到302重定向的时候，并不能像人一样的去准确判定哪一个网址更适当，这就造成了网址URL劫持的可能性。也就是说，一个不道德的人在他自己的网址A做一个302重定向到你的网址B，出于某种原因， Google搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B上的内容，这种情况就叫做网址URL劫持。你辛辛苦苦所写的内容就这样被别人偷走了。</p><ol><li>301：当网页A用301重定向转到网页B时，搜索引擎可以肯定网页A永久的改变位置，或者说实际上不存了，搜索引擎就会把网页B当作唯一有效目标。 <strong>301的好处是</strong>: 第一， 没有网址规范化问题。 第二， 也很重要的，网页A的PR网页级别会传到网页B。</li></ol><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS（全称： Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP 通道，简单讲是 HTTP 的安全版。<strong>即 HTTP 下加入 SSL 层</strong>， HTTPS 的安全基础是 SSL。其所用的端口号是 <strong>443</strong>。 过程大致如下：</p><h4 id="建立连接获取证书"><a href="#建立连接获取证书" class="headerlink" title="建立连接获取证书"></a>建立连接获取证书</h4><p>SSL 客户端通过 TCP 和服务器建立连接之后（443 端口），并且在一般的 tcp 连接协商（握手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息， SSL 的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（<strong>证书里面包含了服务器信息：域名。申请证书的公司，公共秘钥</strong>）</p><h4 id="证书验证"><a href="#证书验证" class="headerlink" title="证书验证"></a>证书验证</h4><p>Client 在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。</p><h4 id="数据加密和传输"><a href="#数据加密和传输" class="headerlink" title="数据加密和传输"></a>数据加密和传输</h4><p>如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。</p><p><img src="HTTP%E4%B8%8EHTTPS%E5%8E%9F%E7%90%86%5Chttp7.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>因特网五层架构</title>
      <link href="/2020/01/20/yin-te-wang-wu-ceng-jia-gou/"/>
      <url>/2020/01/20/yin-te-wang-wu-ceng-jia-gou/</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>TCP/IP 协议不是 TCP 和 IP 这两个协议的合称，而是指因特网整个 TCP/IP 协议族。从协议分层模型方面来讲， <strong>TCP/IP 由四个层次组成：网络接口层、网络层、传输层、应用层</strong>。</p><p><img src="/2020/01/20/yin-te-wang-wu-ceng-jia-gou/%E5%9B%A0%E7%89%B9%E7%BD%91%E4%BA%94%E5%B1%82%E6%9E%B6%E6%9E%84%5Ctcpip1.png" alt="img"></p><h4 id="网络访问层"><a href="#网络访问层" class="headerlink" title="网络访问层"></a>网络访问层</h4><p>网络访问层(Network Access Layer)在 TCP/IP 参考模型中并没有详细描述， <strong>只是指出主机必须使用某种协议与网络相连</strong>。</p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>网络层(Internet Layer)是整个体系结构的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立地传向目标。这些分组可能经由不同的网络，到达的顺序和发送的顺序也可能不同。高层如果需要顺序收发，那么就必须自行处理对分组的排序。 <strong>互联网层使用因特网协议(IP， Internet Protocol)</strong>。</p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>传输层(Tramsport Layer)使源端和目的端机器上的对等实体可以进行会话。 <strong>在这一层定义了两个端到端的协议</strong>：传输控制协议(<strong>TCP</strong>， Transmission Control Protocol)和用户数据报协议(<strong>UDP</strong>， User Datagram Protocol)。 TCP 是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。 UDP 是面向无连接的不可靠传输的协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层(Application Layer)包含所有的高层协议，包括： <strong>虚拟终端协议(TELNET，TELecommunications NETwork)、文件传输协议(FTP， File Transfer Protocol)、电子邮件传输协议(SMTP， Simple Mail Transfer Protocol)、域名服务(DNS， Domain Name Service)、网上新闻传输协议(NNTP， Net News Transfer Protocol)和超文本传送协议(HTTP， HyperText Transfer Protocol)等</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络七层架构</title>
      <link href="/2020/01/20/wang-luo-qi-ceng-jia-gou/"/>
      <url>/2020/01/20/wang-luo-qi-ceng-jia-gou/</url>
      
        <content type="html"><![CDATA[<h3 id="网络七层架构"><a href="#网络七层架构" class="headerlink" title="网络七层架构"></a>网络七层架构</h3><p>7 层模型主要包括：</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。 它的主要作用是传输比特流（就是由 1、 0 转化为电流强弱来进行传输,到达目的地后在转化为1、 0，也就是我们常说的<strong>模数转换与数模转换</strong>）。<strong>这一层的数据叫做比特</strong>。</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>主要将从物理层接收的数据进行 MAC 地址（网卡的地址）的封装与解封装。<strong>常把这一层的数据叫做帧</strong>。在这一层工作的设备是交换机，<strong>数据通过交换机来传输</strong>。</p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>主要将从下层接收到的数据进行 IP 地址（例 192.168.0.1)的封装与解封装。<strong>在这一层工作的设备是路由器</strong>，<strong>常把这一层的数据叫做数据包</strong></p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>定义了一些<strong>传输数据的协议和端口号</strong>（WWW 端口 80 等），如： <strong>TCP</strong>（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据）， <strong>UDP</strong>（用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。常常把这一层数据叫做段</p><h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>通过传输层（端口号：传输端口与接收端口） <strong>建立数据传输的通路</strong>。主要在你的系统之间发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）</p><h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>主要是进行对接收的数据进行<strong>解释、加密与解密、压缩与解压缩</strong>等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等））</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>主要是一些终端的应用，比如说FTP（各种文件下载）， WEB（IE浏览）， QQ之类的（把它理解成我们在电脑屏幕上可以看到的东西．就是终端应用）。</p><p><img src="/2020/01/20/wang-luo-qi-ceng-jia-gou/%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E6%9E%B6%E6%9E%84%5COSIModel.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx使用心得</title>
      <link href="/2020/01/19/nginx-shi-yong-xin-de/"/>
      <url>/2020/01/19/nginx-shi-yong-xin-de/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx-运用小结"><a href="#Nginx-运用小结" class="headerlink" title="Nginx 运用小结"></a>Nginx 运用小结</h1><h4 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h4><p><img src="http://image.augustrush8.com/images/1526187409033.png" alt="img"></p><p>nginx可以作为web服务器，但更多的时候，我们把它作为网关，因为它具备网关必备的功能：</p><ul><li>反向代理</li><li>负载均衡</li><li>动态路由</li><li>请求过滤</li></ul><h3 id="nginx作为web服务器"><a href="#nginx作为web服务器" class="headerlink" title="nginx作为web服务器"></a>nginx作为web服务器</h3><p>Web服务器分2类：</p><ul><li>web应用服务器，如：<ul><li>tomcat</li><li>resin</li><li>jetty</li></ul></li><li>web服务器，如：<ul><li>Apache 服务器</li><li>Nginx</li><li>IIS</li></ul></li></ul><p>区分：web服务器不能解析jsp等页面，只能处理js、css、html等静态资源。 并发：web服务器的并发能力远高于web应用服务器。</p><h3 id="nginx作为反向代理"><a href="#nginx作为反向代理" class="headerlink" title="nginx作为反向代理"></a>nginx作为反向代理</h3><p>什么是反向代理？</p><ul><li>代理：通过客户机的配置，实现让一台服务器(代理服务器)代理客户机，客户的所有请求都交给代理服务器处理。</li><li>反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务器。</li></ul><p>nginx可以当做反向代理服务器来使用：</p><ul><li>我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理</li><li>当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能</li></ul><p>利用反向代理，就可以解决我们前面所说的端口问题，如图</p><p><img src="http://image.augustrush8.com/images/1526016663674.png" alt="1526016663674"></p><h3 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h3><blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3></blockquote><p>安装非常简单，把课前资料提供的nginx直接解压即可，绿色免安装!</p><p>解压后，目录结构：</p><p><img src="/2020/01/19/nginx-shi-yong-xin-de/Nginx%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%5C1579422396676.png" alt="1579422396676"></p><ol><li>conf：配置目录</li><li>contrib：第三方依赖</li><li>html：默认的静态资源目录，类似于tomcat的webapps</li><li>logs：日志目录</li><li>nginx.exe：启动程序。可双击运行，但不建议这么做。</li></ol><blockquote><h3 id="反向代理配置"><a href="#反向代理配置" class="headerlink" title="反向代理配置"></a>反向代理配置</h3></blockquote><p>示例：</p><p><img src="http://image.augustrush8.com/images/1526188831504.png" alt="1526188831504"></p><p>nginx中的每个server就是一个反向代理配置，可以有多个server</p><p>完整配置：</p><pre><code>#user  nobody;worker_processes  1;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    sendfile        on;    keepalive_timeout  65;    gzip  on;    server {        listen       80;        server_name  manage.leyou.com;        proxy_set_header X-Forwarded-Host $host;        proxy_set_header X-Forwarded-Server $host;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        location / {            proxy_pass http://127.0.0.1:9001;            proxy_connect_timeout 600;            proxy_read_timeout 600;        }    }    server {        listen       80;        server_name  api.leyou.com;        proxy_set_header X-Forwarded-Host $host;        proxy_set_header X-Forwarded-Server $host;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        location / {            proxy_pass http://127.0.0.1:10010;            proxy_connect_timeout 600;            proxy_read_timeout 600;        }    }}</code></pre><blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3></blockquote><p>nginx可以通过命令行来启动，操作命令：</p><ul><li>启动：<code>start nginx.exe</code></li><li>停止：<code>nginx.exe -s stop</code></li><li>重新加载：<code>nginx.exe -s reload</code></li></ul><p>启动过程会闪烁一下，启动成功后，任务管理器中会有两个nginx进程：</p><p><img src="http://image.augustrush8.com/images/sshot-1.png" alt="1530385404783"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>启动nginx，然后用域名访问后台管理系统：</p><p><img src="http://image.augustrush8.com/images/screenshot.png" alt="1530385593052"></p><p>现在实现了域名访问网站了，中间的流程是怎样的呢？</p><p><img src="http://image.augustrush8.com/images/1526189945180.png" alt="1526189945180"></p><ol><li><p>浏览器准备发起请求，访问<a href="http://mamage.leyou.com，但需要进行域名解析" target="_blank" rel="noopener">http://mamage.leyou.com，但需要进行域名解析</a></p></li><li><p>优先进行本地域名解析，因为我们修改了hosts，所以解析成功，得到地址：127.0.0.1</p></li><li><p>请求被发往解析得到的ip，并且默认使用80端口：<a href="http://127.0.0.1:80" target="_blank" rel="noopener">http://127.0.0.1:80</a></p><p>本机的nginx一直监听80端口，因此捕获这个请求</p></li><li><p>nginx中配置了反向代理规则，将manage.leyou.com代理到127.0.0.1:9001，因此请求被转发</p></li><li><p>后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx</p></li><li><p>nginx将得到的结果返回到浏览器</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>红黑树的建立与维护</title>
      <link href="/2020/01/16/hong-hei-shu-de-jian-li-yu-wei-hu/"/>
      <url>/2020/01/16/hong-hei-shu-de-jian-li-yu-wei-hu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>队列的用法</title>
      <link href="/2020/01/16/dui-lie-de-yong-fa/"/>
      <url>/2020/01/16/dui-lie-de-yong-fa/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈的性质及一些使用场景</title>
      <link href="/2020/01/16/zhan-de-xing-zhi-ji-yi-xie-shi-yong-chang-jing/"/>
      <url>/2020/01/16/zhan-de-xing-zhi-ji-yi-xie-shi-yong-chang-jing/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HBase建立二级索引的几种方式</title>
      <link href="/2020/01/16/hbase-jian-li-er-ji-suo-yin-de-ji-chong-fang-shi/"/>
      <url>/2020/01/16/hbase-jian-li-er-ji-suo-yin-de-ji-chong-fang-shi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sqoop-HDFS与外界交互数据的工具</title>
      <link href="/2020/01/16/sqoop-hdfs-yu-wai-jie-jiao-hu-shu-ju-de-gong-ju/"/>
      <url>/2020/01/16/sqoop-hdfs-yu-wai-jie-jiao-hu-shu-ju-de-gong-ju/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Flume-大数据采集工具</title>
      <link href="/2020/01/16/flume-da-shu-ju-cai-ji-gong-ju/"/>
      <url>/2020/01/16/flume-da-shu-ju-cai-ji-gong-ju/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>流式处理框架后起之秀Flink</title>
      <link href="/2020/01/16/liu-shi-chu-li-kuang-jia-hou-qi-zhi-xiu-flink/"/>
      <url>/2020/01/16/liu-shi-chu-li-kuang-jia-hou-qi-zhi-xiu-flink/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>真正意义的流式处理框架Strom</title>
      <link href="/2020/01/16/zhen-zheng-yi-yi-de-liu-shi-chu-li-kuang-jia-strom/"/>
      <url>/2020/01/16/zhen-zheng-yi-yi-de-liu-shi-chu-li-kuang-jia-strom/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spark到底好在哪里?</title>
      <link href="/2020/01/16/spark-dao-di-hao-zai-na-li/"/>
      <url>/2020/01/16/spark-dao-di-hao-zai-na-li/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hive-基于MapReduce的数据分析工具</title>
      <link href="/2020/01/16/hive-ji-yu-mapreduce-de-shu-ju-fen-xi-gong-ju/"/>
      <url>/2020/01/16/hive-ji-yu-mapreduce-de-shu-ju-fen-xi-gong-ju/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kafka-大数据的标准数据源</title>
      <link href="/2020/01/16/kafka-da-shu-ju-de-biao-zhun-shu-ju-yuan/"/>
      <url>/2020/01/16/kafka-da-shu-ju-de-biao-zhun-shu-ju-yuan/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HBase的rowkey设计的理解</title>
      <link href="/2020/01/16/hbase-de-rowkey-she-ji-de-li-jie/"/>
      <url>/2020/01/16/hbase-de-rowkey-she-ji-de-li-jie/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop之HDFS上传文件源码分析</title>
      <link href="/2020/01/16/hadoop-zhi-hdfs-shang-chuan-wen-jian-yuan-ma-fen-xi/"/>
      <url>/2020/01/16/hadoop-zhi-hdfs-shang-chuan-wen-jian-yuan-ma-fen-xi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程之缓存与主存一致性</title>
      <link href="/2020/01/15/duo-xian-cheng-zhi-huan-cun-yu-zhu-cun-yi-zhi-xing/"/>
      <url>/2020/01/15/duo-xian-cheng-zhi-huan-cun-yu-zhu-cun-yi-zhi-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="一、总线锁定和缓存一致性"><a href="#一、总线锁定和缓存一致性" class="headerlink" title="一、总线锁定和缓存一致性"></a>一、总线锁定和缓存一致性</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>这是两个操作系统层面的概念。随着多核时代的到来，并发操作已经成了很正常的现象，操作系统必须要有一些机制和原语，以保证某些基本操作的原子性，比如处理器需要保证读一个字节或写一个字节是原子的，那么它是如何实现的呢?有两种机制：总线锁定和缓存一致性。</p><p>我们知道，CPU和物理内存之间的通信速度远慢于CPU的处理速度，所以CPU有自己的内部缓存，根据一些规则将内存中的数据读取到内部缓存中来，以加快频繁读取的速度。我们假设在一台PC上只有一个CPU和一份内部缓存，那么所有进程和线程看到的数都是缓存里的数，不会存在问题;但现在服务器通常是多 CPU，更普遍的是，每块CPU里有多个内核，而每个内核都维护了自己的缓存，那么这时候多线程并发就会存在缓存不一致性，这会导致严重问题。</p><p>以 i++为例，i的初始值是0.那么在开始每块缓存都存储了i的值0，当第一块内核做i++的时候，其缓存中的值变成了1，即使马上回写到主内存，那么在回写之后第二块内核缓存中的i值依然是0，其执行i++，回写到内存就会覆盖第一块内核的操作，使得最终的结果是1，而不是预期中的2.</p><p>那么怎么解决整个问题呢?操作系统提供了总线锁定的机制。前端总线(也叫CPU总线)是所有CPU与芯片组连接的主干道，负责CPU与外界所有部件的通信，包括高速缓存、内存、北桥，其控制总线向各个部件发送控制信号、通过地址总线发送地址信号指定其要访问的部件、通过数据总线双向传输。在CPU1要做 i++操作的时候，其在总线上发出一个LOCK#信号，其他处理器就不能操作缓存了该共享变量内存地址的缓存，也就是阻塞了其他CPU，使该处理器可以独享此共享内存。</p><p>但我们只需要对此共享变量的操作是原子就可以了，而总线锁定把CPU和内存的通信给锁住了，使得在锁定期间，其他处理器不能操作其他内存地址的数据，从而开销较大，所以后来的CPU都提供了缓存一致性机制，Intel的奔腾486之后就提供了这种优化。</p><p>缓存一致性机制整体来说，是当某块CPU对缓存中的数据进行操作了之后，就通知其他CPU放弃储存在它们内部的缓存，或者从主内存中重新读取，如下图：</p><p><img src="/2020/01/15/duo-xian-cheng-zhi-huan-cun-yu-zhu-cun-yi-zhi-xing/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BC%93%E5%AD%98%E4%B8%8E%E4%B8%BB%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%5C20160613151013467.png" alt="20160613151013467"></p><p>这里以在Intel系列中广泛使用的MESI协议详细阐述下其原理。</p><h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><p>MESI 协议是以缓存行(缓存的基本数据单位，在Intel的CPU上一般是64字节)的几个状态来命名的(全名是Modified、Exclusive、 Share or Invalid)。该协议要求在每个缓存行上维护两个状态位，使得每个数据单位可能处于M、E、S和I这四种状态之一，各种状态含义如下：</p><p>M：被修改的。处于这一状态的数据，只在本CPU中有缓存数据，而其他CPU中没有。同时其状态相对于内存中的值来说，是已经被修改的，且没有更新到内存中。</p><p>E：独占的。处于这一状态的数据，只有在本CPU中有缓存，且其数据没有修改，即与内存中一致。</p><p>S：共享的。处于这一状态的数据在多个CPU中都有缓存，且与内存一致。</p><p>I：无效的。本CPU中的这份缓存已经无效。</p><p>这里首先介绍该协议约定的缓存上对应的监听：</p><p>一个处于M状态的缓存行，必须时刻监听所有试图读取该缓存行对应的主存地址的操作，如果监听到，则必须在此操作执行前把其缓存行中的数据写回CPU。</p><p>一个处于S状态的缓存行，必须时刻监听使该缓存行无效或者独享该缓存行的请求，如果监听到，则必须把其缓存行状态设置为I。</p><p>一个处于E状态的缓存行，必须时刻监听其他试图读取该缓存行对应的主存地址的操作，如果监听到，则必须把其缓存行状态设置为S。</p><p>当CPU需要读取数据时，如果其缓存行的状态是I的，则需要从内存中读取，并把自己状态变成S，如果不是I，则可以直接读取缓存中的值，但在此之前，必须要等待其他CPU的监听结果，如其他CPU也有该数据的缓存且状态是M，则需要等待其把缓存更新到内存之后，再读取。</p><p>当CPU需要写数据时，只有在其缓存行是M或者E的时候才能执行，否则需要发出特殊的RFO指令(Read Or Ownership，这是一种总线事务)，通知其他CPU置缓存无效(I)，这种情况下会性能开销是相对较大的。在写入完成后，修改其缓存状态为M。</p><p>所以如果一个变量在某段时间只被一个线程频繁地修改，则使用其内部缓存就完全可以办到，不涉及到总线事务，如果缓存一会被这个CPU独占、一会被那个CPU 独占，这时才会不断产生RFO指令影响到并发性能。这里说的缓存频繁被独占并不是指线程越多越容易触发，而是这里的CPU协调机制，这有点类似于有时多线程并不一定提高效率，原因是线程挂起、调度的开销比执行任务的开销还要大，这里的多CPU也是一样，如果在CPU间调度不合理，也会形成RFO指令的开销比任务开销还要大。当然，这不是编程者需要考虑的事，操作系统会有相应的内存地址的相关判断，这不在本文的讨论范围之内。</p><p>并非所有情况都会使用缓存一致性的，如被操作的数据不能被缓存在CPU内部或操作数据跨越多个缓存行(状态无法标识)，则处理器会调用总线锁定;另外当CPU不支持缓存锁定时，自然也只能用总线锁定了，比如说奔腾486以及更老的CPU。</p><h2 id="二、CAS-Compare-and-Swap"><a href="#二、CAS-Compare-and-Swap" class="headerlink" title="二、CAS(Compare and Swap)"></a>二、CAS(Compare and Swap)</h2><p>有了上一章的总线锁定和缓存一致性的介绍，对CAS就比较好理解了，这不是java特有的，而是操作系统需要保证的。CAS指令在Intel CPU上称为CMPXCHG指令，它的作用是将指定内存地址的内容与所给的某个值相比，如果相等，则将其内容替换为指令中提供的新值，如果不相等，则更新失败。这一比较并交换的操作是原子的，不可以被中断，而其保证原子性的原理就是上一节提到的“总线锁定和缓存一致性”。初一看，CAS也包含了读取、比较 (这也是种操作)和写入这三个操作，和之前的i++并没有太大区别，是的，的确在操作上没有区别，但CAS是通过硬件命令保证了原子性，而i++没有，且硬件级别的原子性比i++这样高级语言的软件级别的运行速度要快地多。虽然CAS也包含了多个操作，但其的运算是固定的(就是个比较)，这样的锁定性能开销很小。</p><p>随着互联网行业的兴起和硬件多CPU/多内核的进步，高并发已经成为越来越普遍的现象，CAS已经被越来越广泛地使用，在Java领域也是如此。JDK1.4是2002年2月发布的，当时的硬件设备远没有如今这么先进，多CPU和多核还没有普及，所以在JDK1.5之前的synchronized是使用挂起线程、等待调度的方式来实现线程同步，开销较大;而随着硬件的不断升级，在2004年9月发布的JDK5中引入了CAS机制——比较并交换——来彻底解决此问题，在一般情况下不再需要挂起(参考后文对锁级别的描述，只有进入重量级锁的时候才会使用挂起)，而是多次尝试，其利用底层CPU命令实现的乐观锁机制。从内存领域来说这是乐观锁，因为它在对共享变量更新之前会先比较当前值是否与更新前的值一致，如果是，则更新，如果不是，则无限循环执行(称为自旋)，直到当前值与更新前的值一致为止，才执行更新。</p><p>以concurrent中的AtomicInteger的代码为例，其的getAndIncrement()方法(获得并且自增，即i++)源代码如下：</p><pre><code>   /**      * Atomically increments by one the current value.      *      * @return the previous value      */     public final int getAndIncrement() {         for (;;) {             int current = get();             int next = current + 1 ;             if (compareAndSet(current, next))                 return current;         }     } /**  * Atomically sets the value to the given updated value  * if the current value {@code ==} the expected value.  *  * @param expect the expected value  * @param update the new value  * @return true if successful. False return indicates that  * the actual value was not equal to the expected value.  */ public final boolean compareAndSet( int expect, int update) {     return unsafe.compareAndSwapInt( this , valueOffset, expect, update); }</code></pre><p>其调用了compareAndSet(int expect,int update)方法，其中expect是期望值，即操作前的原始值，而update是操作后的值，以i=2为例，则这里的 expect=2，update=3，它调用了sun.misc.Unsafe的compareAndSwapInt方法来执行，此方法代码如下：</p><pre><code>/***    * Compares the value of the integer field at the specified offset    * in the supplied object with the given expected value, and updates    * it if they match.  The operation of this method should be atomic,    * thus providing an uninterruptible way of updating an integer field.    *    * @param obj the object containing the field to modify.    * @param offset the offset of the integer field within &lt;code&gt;obj&lt;/code&gt;.    * @param expect the expected value of the field.    * @param update the new value of the field if it equals &lt;code&gt;expect&lt;/code&gt;.    * @return true if the field was changed.    */   public native boolean compareAndSwapInt(Object obj, long offset,                                           int expect, int update);</code></pre><p>这是一个本地方法，即利用CAS保证其原子性，同时如果失败了则通过循环不断地进行运算直到成功为止，这是和JDK5以前最大的区别，失败的线程不再需要被挂起、重新调度，而是可以无障碍地再度执行，这又极大减少了挂起调度的开销(当然如果CAS长时间不成功，也会造成耗费CPU，这取决于具体应用场景)。</p><p>CAS策略有如下需要注意的事项：</p><p>在线程抢占资源特别频繁的时候(相对于CPU执行效率而言)，会造成长时间的自旋，耗费CPU性能。</p><p>有ABA问题(即在更新前的值是A，但在操作过程中被其他线程更新为B，又更新为 A)，这时当前线程认为是可以执行的，其实是发生了不一致现象，如果这种不一致对程序有影响(真正有这种影响的场景很少，除非是在变量操作过程中以此变量为标识位做一些其他的事，比如初始化配置)，则需要使用AtomicStampedReference(除了对更新前的原值进行比较，也需要用更新前的 stamp标志位来进行比较)。</p><p>只能对一个变量进行原子性操作。如果需要把多个变量作为一个整体来做原子性操作，则应该使用AtomicReference来把这些变量放在一个对象里，针对这个对象做原子性操作。</p><p>CAS在JDK5中被J.U.C包广泛使用，在JDK6中被应用到synchronized的 JVM实现中，因此在JDK5中J.U.C的效率是比synchronized高不少的，而到了JDK6，两者效率相差无几，而synchronized 使用更简单、更不容易出错，所以其是专家组推荐的首选，除非需要用到J.U.C的特殊功能(如阻塞一段时间后放弃，而不是继续等待)。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Netty原理</title>
      <link href="/2020/01/14/netty-yuan-li/"/>
      <url>/2020/01/14/netty-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="Netty架构原理，不怕你看不懂！"><a href="#Netty架构原理，不怕你看不懂！" class="headerlink" title="Netty架构原理，不怕你看不懂！"></a>Netty架构原理，不怕你看不懂！</h2><p>对于高性能的 RPC 框架，Netty 作为异步通信框架，几乎成为必备品。例如，Dubbo 框架中通信组件，还有 RocketMQ 中生产者和消费者的通信，都使用了 Netty。今天，我们来看看 Netty 的基本架构和原理。</p><p>Netty 的特点与 NIO</p><p>Netty 是一个异步的、基于事件驱动的网络应用框架，它可以用来开发高性能服务端和客户端。</p><p>以前编写网络调用程序的时候，我们都会在客户端创建一个 Socket，通过这个 Socket 连接到服务端。</p><p>服务端根据这个 Socket 创建一个 Thread，用来发出请求。客户端在发起调用以后，需要等待服务端处理完成，才能继续后面的操作。这样线程会出现等待的状态。</p><p>如果客户端请求数越多，服务端创建的处理线程也会越多，JVM 如此多的线程并不是一件容易的事。</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><em>使用阻赛 I/O 处理多个连接</em></p><p>为了解决上述的问题，推出了 NIO 的概念，也就是（Non-blocking I/O）。其中，Selector 机制就是 NIO 的核心。</p><p>当每次客户端请求时，会创建一个 Socket Channel，并将其注册到 Selector 上（多路复用器）。</p><p>然后，Selector 关注服务端 IO 读写事件，此时客户端并不用等待 IO 事件完成，可以继续做接下来的工作。</p><p>一旦，服务端完成了 IO 读写操作，Selector 会接到通知，同时告诉客户端 IO 操作已经完成。</p><p>接到通知的客户端，就可以通过 SocketChannel 获取需要的数据了。</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><em>NIO 机制与 Selector</em></p><p>上面描述的过程有点异步的意思，不过，Selector 实现的并不是真正意义上的异步操作。</p><p>因为 Selector 需要通过线程阻塞的方式监听 IO 事件变更，只是这种方式没有让客户端等待，是 Selector 在等待 IO 返回，并且通知客户端去获取数据。真正“异步 IO”（AIO）这里不展开介绍，有兴趣可以自行查找。</p><p>说好了 NIO 再来谈谈 Netty，Netty 作为 NIO 的实现，它适用于服务器/客户端通讯的场景，以及针对于 TCP 协议下的高并发应用。</p><p>对于开发者来说，它具有以下特点：</p><ul><li>对 NIO 进行封装，开发者不需要关注 NIO 的底层原理，只需要调用 Netty 组件就能够完成工作。</li><li>对网络调用透明，从 Socket 建立 TCP 连接到网络异常的处理都做了包装。</li><li>对数据处理灵活， Netty 支持多种序列化框架，通过“ChannelHandler”机制，可以自定义“编/解码器”。</li><li>对性能调优友好，Netty 提供了线程池模式以及 Buffer 的重用机制（对象池化），不需要构建复杂的多线程模型和操作队列。</li></ul><p># </p><p>从一个简单的例子开始</p><p>开篇讲到了，为了满足高并发下网络请求，引入了 NIO 的概念。Netty 是针对 NIO 的实现，在 NIO 封装，网络调用，数据处理以及性能优化等方面都有不俗的表现。</p><p>学习架构最容易的方式就是从实例入手，从客户端访问服务端的代码来看看 Netty 是如何运作的。再一次介绍代码中调用的组件以及组件的工作原理。</p><p>假设有一个客户端去调用一个服务端，假设服务端叫做 EchoServer，客户端叫做 EchoClient，用 Netty 架构实现代码如下。</p><p><strong>服务端代码</strong></p><p>构建服务器端，假设服务器接受客户端传来的信息，然后在控制台打印。首先，生成 EchoServer，在构造函数中传入需要监听的端口号。</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><em>构造函数中传入需要监听的端口号</em></p><p>接下来就是服务的启动方法：</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><em>启动 NettyServer 的 Start 方法</em></p><p>Server 的启动方法涉及到了一些组件的调用，例如 EventLoopGroup，Channel。这些会在后面详细讲解。</p><p>这里有个大致的印象就好：</p><ul><li>创建 EventLoopGroup。</li><li>创建 ServerBootstrap。</li><li>指定所使用的 NIO 传输 Channel。</li><li>使用指定的端口设置套接字地址。</li><li>添加一个 ServerHandler 到 Channel 的 ChannelPipeline。</li><li>异步地绑定服务器；调用 sync() 方法阻塞等待直到绑定完成。</li><li>获取 Channel 的 CloseFuture，并且阻塞当前线程直到它完成。</li><li>关闭 EventLoopGroup，释放所有的资源。</li></ul><p>NettyServer 启动以后会监听某个端口的请求，当接受到了请求就需要处理了。在 Netty 中客户端请求服务端，被称为“入站”操作。</p><p>可以通过 ChannelInboundHandlerAdapter 实现，具体内容如下：</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><em>处理来自客户端的请求</em></p><p>从上面的代码可以看出，服务端处理的代码包含了三个方法。这三个方法都是根据事件触发的。</p><p>他们分别是：</p><ul><li>当接收到消息时的操作，channelRead。</li><li>消息读取完成时的方法，channelReadComplete。</li><li>出现异常时的方法，exceptionCaught。</li></ul><p><strong>客户端代码</strong></p><p>客户端和服务端的代码基本相似，在初始化时需要输入服务端的 IP 和 Port。</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>同样在客户端启动函数中包括以下内容：</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>客户端启动程序的顺序：</p><ul><li>创建 Bootstrap。</li><li>指定 EventLoopGroup 用来监听事件。</li><li>定义 Channel 的传输模式为 NIO（Non-BlockingInputOutput）。</li><li>设置服务器的 InetSocketAddress。</li><li>在创建 Channel 时，向 ChannelPipeline 中添加一个 EchoClientHandler 实例。</li><li>连接到远程节点，阻塞等待直到连接完成。</li><li>阻塞，直到 Channel 关闭。</li><li>关闭线程池并且释放所有的资源。</li></ul><p>客户端在完成以上操作以后，会与服务端建立连接从而传输数据。同样在接受到 Channel 中触发的事件时，客户端会触发对应事件的操作。</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>例如 Channel 激活，客户端接受到服务端的消息，或者发生异常的捕获。</p><p>从代码结构上看还是比较简单的。服务端和客户端分别初始化创建监听和连接。然后分别定义各自的 Handler 处理对方的请求。</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><em>服务端/客户端初始化和事件处理</em></p><p>Netty 核心组件</p><p>通过上面的简单例子，发现有些 Netty 组件在服务初始化以及通讯时被用到，下面就来介绍一下这些组件的用途和关系。</p><h2 id="①Channel"><a href="#①Channel" class="headerlink" title="①Channel"></a><strong>①Channel</strong></h2><p>通过上面例子可以看出，当客户端和服务端连接的时候会建立一个 Channel。</p><p>这个 Channel 我们可以理解为 Socket 连接，它负责基本的 IO 操作，例如：bind（），connect（），read（），write（） 等等。</p><p>简单的说，Channel 就是代表连接，实体之间的连接，程序之间的连接，文件之间的连接，设备之间的连接。同时它也是数据入站和出站的载体。</p><h2 id="②EventLoop-和-EventLoopGroup"><a href="#②EventLoop-和-EventLoopGroup" class="headerlink" title="②EventLoop 和 EventLoopGroup"></a><strong>②EventLoop 和 EventLoopGroup</strong></h2><p>既然有了 Channel 连接服务，让信息之间可以流动。如果服务发出的消息称作“出站”消息，服务接受的消息称作“入站”消息。那么消息的“出站”/“入站”就会产生事件（Event）。</p><p>例如：连接已激活；数据读取；用户事件；异常事件；打开链接；关闭链接等等。</p><p>顺着这个思路往下想，有了数据，数据的流动产生事件，那么就有一个机制去监控和协调事件。</p><p>这个机制（组件）就是 EventLoop。在 Netty 中每个 Channel 都会被分配到一个 EventLoop。一个 EventLoop 可以服务于多个 Channel。</p><p>每个 EventLoop 会占用一个 Thread，同时这个 Thread 会处理 EventLoop 上面发生的所有 IO 操作和事件（Netty 4.0）。</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><em>EventLoop 与 Channel 关系</em></p><p>理解了 EventLoop，再来说 EventLoopGroup 就容易了，EventLoopGroup 是用来生成 EventLoop 的，还记得例子代码中第一行就 new 了 EventLoopGroup 对象。</p><p>一个 EventLoopGroup 中包含了多个 EventLoop 对象。</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><em>创建 EventLoopGroup</em></p><p>EventLoopGroup 要做的就是创建一个新的 Channel，并且给它分配一个 EventLoop。</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><em>EventLoopGroup，EventLoop 和 Channel 的关系</em></p><p>在异步传输的情况下，一个 EventLoop 是可以处理多个 Channel 中产生的事件的，它主要的工作就是事件的发现以及通知。</p><p>相对于以前一个 Channel 就占用一个 Thread 的情况。Netty 的方式就要合理多了。</p><p>客户端发送消息到服务端，EventLoop 发现以后会告诉服务端：“你去获取消息”，同时客户端进行其他的工作。</p><p>当 EventLoop 检测到服务端返回的消息，也会通知客户端：“消息返回了，你去取吧“。客户端再去获取消息。整个过程 EventLoop 就是监视器+传声筒。</p><h2 id="③ChannelHandler，ChannelPipeline-和-ChannelHandlerContext"><a href="#③ChannelHandler，ChannelPipeline-和-ChannelHandlerContext" class="headerlink" title="③ChannelHandler，ChannelPipeline 和 ChannelHandlerContext"></a><strong>③ChannelHandler，ChannelPipeline 和 ChannelHandlerContext</strong></h2><p>如果说 EventLoop 是事件的通知者，那么 ChannelHandler 就是事件的处理者。</p><p>在 ChannelHandler 中可以添加一些业务代码，例如数据转换，逻辑运算等等。</p><p>正如上面例子中展示的，Server 和 Client 分别都有一个 ChannelHandler 来处理，读取信息，网络可用，网络异常之类的信息。</p><p>并且，针对出站和入站的事件，有不同的 ChannelHandler，分别是：</p><ul><li><strong>ChannelInBoundHandler（入站事件处理器）</strong></li><li><strong>ChannelOutBoundHandler（出站事件处理器）</strong></li></ul><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>假设每次请求都会触发事件，而由 ChannelHandler 来处理这些事件，这个事件的处理顺序是由 ChannelPipeline 来决定的。</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><em>ChannelHanlder 处理，出站/入站的事件</em></p><p>ChannelPipeline 为 ChannelHandler 链提供了容器。到 Channel 被创建的时候，会被 Netty 框架自动分配到 ChannelPipeline 上。</p><p>ChannelPipeline 保证 ChannelHandler 按照一定顺序处理事件，当事件触发以后，会将数据通过 ChannelPipeline 按照一定的顺序通过 ChannelHandler。</p><p>说白了，ChannelPipeline 是负责“排队”的。这里的“排队”是处理事件的顺序。</p><p>同时，ChannelPipeline 也可以添加或者删除 ChannelHandler，管理整个队列。</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>如上图，ChannelPipeline 使 ChannelHandler 按照先后顺序排列，信息按照箭头所示方向流动并且被 ChannelHandler 处理。</p><p>说完了 ChannelPipeline 和 ChannelHandler，前者管理后者的排列顺序。那么它们之间的关联就由 ChannelHandlerContext 来表示了。</p><p>每当有 ChannelHandler 添加到 ChannelPipeline 时，同时会创建 ChannelHandlerContext 。</p><p>ChannelHandlerContext 的主要功能是管理 ChannelHandler 和 ChannelPipeline 的交互。</p><p>不知道大家注意到没有，开始的例子中 ChannelHandler 中处理事件函数，传入的参数就是 ChannelHandlerContext。</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>ChannelHandlerContext 参数贯穿 ChannelPipeline，将信息传递给每个 ChannelHandler，是个合格的“通讯员”。</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><em>ChannelHandlerContext 负责传递消息</em></p><p>把上面提到的几个核心组件归纳一下，用下图表示方便记忆他们之间的关系。</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><em>Netty 核心组件关系图</em></p><p>Netty 的数据容器</p><p>前面介绍了 Netty 的几个核心组件，服务器在数据传输的时候，产生事件，并且对事件进行监控和处理。</p><p>接下来看看数据是如何存放以及是如何读写的。Netty 将 ByteBuf 作为数据容器，来存放数据。</p><p><strong>ByteBuf 工作原理</strong></p><p>从结构上来说，ByteBuf 由一串字节数组构成。数组中每个字节用来存放信息。</p><p>ByteBuf 提供了两个索引，一个用于读取数据，一个用于写入数据。这两个索引通过在字节数组中移动，来定位需要读或者写信息的位置。</p><p>当从 ByteBuf 读取时，它的 readerIndex（读索引）将会根据读取的字节数递增。</p><p>同样，当写 ByteBuf 时，它的 writerIndex 也会根据写入的字节数进行递增。</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><em>ByteBuf 读写索引图例</em></p><p>需要注意的是极限的情况是 readerIndex 刚好读到了 writerIndex 写入的地方。</p><p>如果 readerIndex 超过了 writerIndex 的时候，Netty 会抛出 IndexOutOf-BoundsException 异常。</p><p><strong>ByteBuf 使用模式</strong></p><p>谈了 ByteBuf 的工作原理以后，再来看看它的使用模式。</p><p>根据存放缓冲区的不同分为三类：</p><ul><li><p><strong>堆缓冲区，</strong>ByteBuf 将数据存储在 JVM 的堆中，通过数组实现，可以做到快速分配。</p><p>由于在堆上被 JVM 管理，在不被使用时可以快速释放。可以通过 ByteBuf.array() 来获取 byte[] 数据。</p></li><li><p><strong>直接缓冲区，</strong>在 JVM 的堆之外直接分配内存，用来存储数据。其不占用堆空间，使用时需要考虑内存容量。</p><p>它在使用 Socket 传递时性能较好，因为间接从缓冲区发送数据，在发送之前 JVM 会先将数据复制到直接缓冲区再进行发送。</p><p>由于，直接缓冲区的数据分配在堆之外，通过 JVM 进行垃圾回收，并且分配时也需要做复制的操作，因此使用成本较高。</p></li><li><p><strong>复合缓冲区，</strong>顾名思义就是将上述两类缓冲区聚合在一起。Netty 提供了一个 CompsiteByteBuf，可以将堆缓冲区和直接缓冲区的数据放在一起，让使用更加方便。</p></li></ul><p><strong>ByteBuf 的分配</strong></p><p>聊完了结构和使用模式，再来看看 ByteBuf 是如何分配缓冲区的数据的。</p><p>Netty 提供了两种 ByteBufAllocator 的实现，他们分别是：</p><ul><li><strong>PooledByteBufAllocator，</strong>实现了 ByteBuf 的对象的池化，提高性能减少内存碎片。</li><li><strong>Unpooled-ByteBufAllocator，</strong>没有实现对象的池化，每次会生成新的对象实例。</li></ul><p>对象池化的技术和线程池，比较相似，主要目的是提高内存的使用率。池化的简单实现思路，是在 JVM 堆内存上构建一层内存池，通过 allocate 方法获取内存池中的空间，通过 release 方法将空间归还给内存池。</p><p>对象的生成和销毁，会大量地调用 allocate 和 release 方法，因此内存池面临碎片空间回收的问题，在频繁申请和释放空间后，内存池需要保证连续的内存空间，用于对象的分配。</p><p>基于这个需求，有两种算法用于优化这一块的内存分配：伙伴系统和 slab 系统。</p><p>伙伴系统，用完全二叉树管理内存区域，左右节点互为伙伴，每个节点代表一个内存块。内存分配将大块内存不断二分，直到找到满足所需的最小内存分片。</p><p>内存释放会判断释放内存分片的伙伴（左右节点）是否空闲，如果空闲则将左右节点合成更大块内存。</p><p>slab 系统，主要解决内存碎片问题，将大块内存按照一定内存大小进行等分，形成相等大小的内存片构成的内存集。</p><p>按照内存申请空间的大小，申请尽量小块内存或者其整数倍的内存，释放内存时，也是将内存分片归还给内存集。</p><p>Netty 内存池管理以 Allocate 对象的形式出现。一个 Allocate 对象由多个 Arena 组成，每个 Arena 能执行内存块的分配和回收。</p><p>Arena 内有三类内存块管理单元：</p><ul><li><strong>TinySubPage</strong></li><li><strong>SmallSubPage</strong></li><li><strong>ChunkList</strong></li></ul><p>Tiny 和 Small 符合 Slab 系统的管理策略，ChunkList 符合伙伴系统的管理策略。</p><p>当用户申请内存介于 tinySize 和 smallSize 之间时，从 tinySubPage 中获取内存块。</p><p>申请内存介于 smallSize 和 pageSize 之间时，从 smallSubPage 中获取内存块；介于 pageSize 和 chunkSize 之间时，从 ChunkList 中获取内存；大于 ChunkSize（不知道分配内存的大小）的内存块不通过池化分配。</p><p>Netty 的 Bootstrap</p><p>说完了 Netty 的核心组件以及数据存储。再回到最开始的例子程序，在程序最开始的时候会 new 一个 Bootstrap 对象，后面所有的配置都是基于这个对象展开的。</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><em>生成 Bootstrap 对象</em></p><p>Bootstrap 的作用就是将 Netty 核心组件配置到程序中，并且让他们运行起来。</p><p>从 Bootstrap 的继承结构来看，分为两类分别是 Bootstrap 和 ServerBootstrap，一个对应客户端的引导，另一个对应服务端的引导。</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><em>支持客户端和服务端的程序引导</em></p><p>客户端引导 Bootstrap，主要有两个方法 bind（） 和 connect（）。Bootstrap 通过 bind（） 方法创建一个 Channel。</p><p>在 bind（） 之后，通过调用 connect（） 方法来创建 Channel 连接。</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><em>Bootstrap 通过 bind 和 connect 方法创建连接</em></p><p>服务端引导 ServerBootstrap，与客户端不同的是在 Bind（） 方法之后会创建一个 ServerChannel，它不仅会创建新的 Channel 还会管理已经存在的 Channel。</p><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p>ServerBootstrap 通过 bind 方法创建/管理连接</p><p>通过上面的描述，服务端和客户端的引导存在两个区别：</p><ul><li><p>ServerBootstrap（服务端引导）绑定一个端口，用来监听客户端的连接请求。而 Bootstrap（客户端引导）只要知道服务端 IP 和 Port 建立连接就可以了。</p></li><li><p>Bootstrap（客户端引导）需要一个 EventLoopGroup，但是 ServerBootstrap（服务端引导）则需要两个 EventLoopGroup。</p><p>因为服务器需要两组不同的 Channel。第一组 ServerChannel 自身监听本地端口的套接字。第二组用来监听客户端请求的套接字。</p></li></ul><p><img src="/2020/01/14/netty-yuan-li/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><em>ServerBootstrap 有两组 EventLoopGroup</em></p><p>总结</p><p>我们从 NIO 入手，谈到了 Selector 的核心机制。然后通过介绍 Netty 客户端和服务端源代码运行流程，让大家对 Netty 编写代码有基本的认识。</p><p>在 Netty 的核心组件中，Channel 提供 Socket 的连接通道，EventLoop 会对应 Channel 监听其产生的事件，并且通知执行者。EventloopGroup 的容器，负责生成和管理 EventLoop。</p><p>ChannelPipeline 作为 ChannelHandler 的容器会绑定到 Channel 上，然后由 ChannelHandler 提供具体事件处理。另外，ChannelHandlerContext 为 ChannelHandler 和 ChannelPipeline 提供信息共享。</p><p>ByteBuf 作为 Netty 的数据容器，通过字节数组的方式存储数据，并且通过读索引和写索引来引导读写操作。</p><p>上述的核心组件都是通过 Bootstrap 来配置并且引导启动的，Bootstrap 启动方式虽然一致，但是针对客户端和服务端有些许的区别。</p><p><em>作者：崔皓</em></p><p><em>简介：十六年开发和架构经验，曾担任过惠普武汉交付中心技术专家，需求分析师，项目经理，后在创业公司担任技术/产品经理。善于学习，乐于分享。目前专注于技术架构与研发管理。</em></p>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java的Object对象</title>
      <link href="/2020/01/13/java-de-object-dui-xiang/"/>
      <url>/2020/01/13/java-de-object-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="一-Object对象简介"><a href="#一-Object对象简介" class="headerlink" title="一.Object对象简介"></a>一.Object对象简介</h2><p>我们学Java的知道，Java是一门面向对象的语言。无论在Java中出现什么，都可以认为它是对象(<strong>除了</strong>八大基本数据类型。当然了，八大基本数据类型也能<strong>装箱</strong>成为对象)：</p><ul><li>而Object就是这些对象的最高级别的，所有的Java对象都<strong>隐式</strong>地继承了Object对象(不用显示写<code>extends</code>继承)</li><li>所有的Java对象都<strong>拥有Object默认的方法</strong>。</li></ul><p>那么我们看看Object有什么方法：</p><p><img src="/2020/01/13/java-de-object-dui-xiang/D:%5CMyBlot%5Cbolt%5Csource_posts%5Cjava%E7%9A%84Object%E5%AF%B9%E8%B1%A1%5C1578923575140.png" alt="1578923575140"></p><p>其实就可以归纳成几个：</p><ul><li><code>registerNatives()</code>【底层实现、不研究】</li><li><code>hashCode()</code></li><li><code>equals(Object obj)</code></li><li><code>clone()</code></li><li><code>toString()</code></li><li><code>notify()</code></li><li><code>notifyAll()</code></li><li><code>wait(long timeout)</code>【还有重载了两个】</li><li><code>finalize()</code></li></ul><p>Object一共有<strong>11</strong>个方法，其中一个为底层的实现<code>registerNatives()</code>，其中两个<code>wait()</code>和<code>wait(long timeout, int nanos)</code>重载方法。</p><ul><li>所以我们真正需要看的就是<strong>8个</strong>方法</li></ul><p>还有<strong>一个属性</strong>：</p><pre><code> public final native Class&lt;?&gt; getClass();</code></pre><p><img src="/2020/01/13/java-de-object-dui-xiang/D:%5CMyBlot%5Cbolt%5Csource_posts%5Cjava%E7%9A%84Object%E5%AF%B9%E8%B1%A1%5C1.png" alt="img"></p><h2 id="二、equals和hashCode方法"><a href="#二、equals和hashCode方法" class="headerlink" title="二、equals和hashCode方法"></a>二、equals和hashCode方法</h2><p>equals和hashCode方法可以说是面试的重点题了，配合着String可以说在面试题中<strong>哪都有它们的存在</strong>。</p><p>首先，我们来看看equals和hashCode在Object中<strong>原生</strong>的实现吧：</p><p>hashCode：</p><pre><code>public native int hashCode();复制代码</code></pre><p>equals：</p><pre><code>    public boolean equals(Object obj) {        return (this == obj);    }复制代码</code></pre><p>看上去都非常简单：</p><ul><li><code>hashCode()</code>由native方法底层实现了。</li><li><code>equals()</code>就直接<code>==</code>判断是否相等了。</li></ul><p>想要更加清晰它们究竟是做什么的，我们来读读它的注释：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16324c7a3826e201?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16324c6dd98fafb9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>根据注释我们可以<strong>总结以下的要点</strong>：</p><ul><li><p>重写<code>equals()</code>方法，就必须重写<code>hashCode()</code>的方法</p></li><li><p><code>equals()</code>方法默认是比较对象的地址，使用的是<code>==</code>等值运算符</p></li><li><p><code>hashCode()</code>方法对底层是散列表的对象有提升性能的功能</p></li><li><p>同一个对象(如果该对象没有被修改)：那么重复调用<code>hashCode()</code>那么返回的int是相同的！</p></li><li><p><code>hashCode()</code>方法默认是由对象的地址转换而来的</p></li><li><pre><code>equals()</code></pre><p>方法还有5个默认的原则：</p><ul><li>自反性—&gt;调用<code>equals()</code>返回的是true，无论这两个对象谁调用<code>equals()</code>都好，返回的都是true</li><li>一致性—&gt;只要对象没有被修改，那么多次调用还是返回对应的结果！</li><li>传递性—&gt;<code>x.equals(y)</code>和<code>y.equals(z)</code>都返回true，那么可以得出：<code>x.equals(z)</code>返回true</li><li>对称性—&gt;<code>x.equals(y)</code>和<code>y.equals(x)</code>结果应该是相等的。</li><li>传入的参数为null，返回的是false</li></ul></li></ul><p>为啥说<code>hashCode()</code>以散列表为底层带来性能的提升是很容易理解的。我们再来<strong>回顾</strong>一下HashMap的插入：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16324c6dc3ba8c3e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>如果hash值都不相等，那么可以直接判断该key是不相等的了！</p><h3 id="2-1equals和hashCode方法重写"><a href="#2-1equals和hashCode方法重写" class="headerlink" title="2.1equals和hashCode方法重写"></a>2.1equals和hashCode方法重写</h3><p><code>equals()</code>方法默认是比较对象的地址，使用的是<code>==</code>等值运算符。但是按我们正常开发来说，<strong>比较的是对象地址是没有意义的</strong>。</p><ul><li>一般地，如果我们有两个Address对象，只要这两个对象的<strong>省号、城市号、街道号相等</strong>，我们就认为这两个对象相等了！</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16324c6bae49e75a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="2-2String实现的equals和hashCode方法"><a href="#2-2String实现的equals和hashCode方法" class="headerlink" title="2.2String实现的equals和hashCode方法"></a>2.2String实现的equals和hashCode方法</h3><p>我们在初学的时候可能就听过了：String<strong>已经</strong>实现了equals和hashCode方法了。</p><ul><li>这也就是为什么，我们可以<strong>直接</strong>使用String.equals()来<strong>判断两个字符串</strong>是否相等！</li></ul><p>下面我们就来看看它的实现吧：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16324c6bf58f1e99?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16324c6bf1509f15?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h1 id="三、toString方法"><a href="#三、toString方法" class="headerlink" title="三、toString方法"></a>三、toString方法</h1><p>接下来我们看看toString方法，也十分简单：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16324c6c36facd57?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>toString方法主要是用来<strong>标识</strong>该对象的：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16324c6c48984185?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>从上面的结果我们都可以看出来：<strong>得出的结果我们并不能看到什么东西</strong>~</p><p>于是我们一般都重写toString()，那么<strong>打印出的结果就很方便我们调试了</strong>！</p><pre><code>    @Override    public String toString() {        return &quot;Address{&quot; +                &quot;provinceNo=&quot; + provinceNo +                &quot;, cityNo=&quot; + cityNo +                &quot;, streetNo=&quot; + streetNo +                &#39;}&#39;;    }复制代码</code></pre><p>下面的结果看起来就好多了：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16324c6c5155fd2c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h1 id="四、clone方法"><a href="#四、clone方法" class="headerlink" title="四、clone方法"></a>四、clone方法</h1><p>我们也来看看它的顶部注释：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16324c6c5fd4239f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>看了上面的注释我们可以<strong>总结以下的要点</strong>：</p><ul><li>clone方法用于对象的克隆，一般想要克隆出的对象是<strong>独立</strong>的(与原有的对象是分开的)</li><li>深拷贝指的是该对象的成员变量(如果是可变引用)都应该克隆一份，浅拷贝指的是成员变量没有被克隆一份</li></ul><p>下面我们来看一下浅拷贝：<strong>拷贝了Employee对象，但是其成员变量hireday没有被克隆出去，所以指向的还是同一个Date对象</strong>！</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16324c6c8d1dd69f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="4-1clone用法"><a href="#4-1clone用法" class="headerlink" title="4.1clone用法"></a>4.1clone用法</h2><p>那么我们如何克隆对象呢？无论是浅拷贝还是深拷贝都是这两步：</p><ol><li>克隆的对象要<strong>实现Cloneable接口</strong></li><li><strong>重写clone方法</strong>，最好修饰成public</li></ol><p><strong>浅拷贝</strong>：仅仅拷贝了Person对象，而date没有拷贝！</p><pre><code>public class Person implements Cloneable {    // 可变的成员变量    private Date date;    @Override    public Object clone() throws CloneNotSupportedException {        return super.clone();    }}复制代码</code></pre><p><strong>深拷贝</strong>：不仅拷贝了Person对象，也拷贝了date成员变量</p><pre><code>public class Person implements Cloneable {    // 可变的成员变量    public  Date date;    @Override    public Object clone() throws CloneNotSupportedException {        // 拷贝Person对象        Person person = (Person) super.clone();        // 将可变的成员变量也拷贝        person.date = (Date) date.clone();        // 返回拷贝的对象        return person;    }}复制代码</code></pre><h2 id="4-2clone疑问进一步学习protected"><a href="#4-2clone疑问进一步学习protected" class="headerlink" title="4.2clone疑问进一步学习protected"></a>4.2clone疑问进一步学习protected</h2><p>不知道有没有人跟我有相同的<strong>疑问</strong>：</p><ul><li>我只想要<strong>浅拷贝</strong>，能不能<strong>直接调用该对象.clone()来实现</strong>？</li></ul><p>比如我现在有个Address对象：</p><pre><code>public class Address  {    private int provinceNo;    private int cityNo;    private int streetNo;    public Address() {    }    public Address(int provinceNo, int cityNo, int streetNo) {        this.provinceNo = provinceNo;        this.cityNo = cityNo;        this.streetNo = streetNo;    }}复制代码</code></pre><p>下面的代码你们<strong>认为如何</strong>？</p><pre><code>    Address address = new Address(1, 2, 3);    address.clone();复制代码</code></pre><p>我们都知道：</p><ul><li><strong>protected修饰的类和属性,对于自己、本包和其子类可见</strong></li></ul><p><strong>可能会想</strong>：<code>clone()</code>方法是定义在Object类上的(以protected来修饰)，而我们自定义的Address对象<strong>隐式</strong>继承着Object(所有的对象都是Object的子类)，那么子类调用Object以protected来修饰<code>clone()</code>是完全没问题的</p><ul><li>但是，IDE现实告诉我，这<strong>编译就不通过了</strong>！</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16324c6cb2a8e1aa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>出现错误的原因我立马就想到：<strong>是不是我对protected修饰符出现了偏差？</strong></p><p>protected修饰的类和属性,对于自己、本包和其子类可见，这句话本身是没有错的。但是<strong>还需要补充</strong>：对于protected的成员或方法，要分子类和超类<strong>是否在同一个包中</strong>。与基类<strong>不在同一个包中的子类</strong>，只能<strong>访问自身从基类继承而来的受保护成员，而不能访问基类实例本身的受保护成员</strong>。</p><ul><li>上面的代码就错在：Address与Object<strong>不是在同一个包下</strong>的，而Address直接访问了Object的clone方法。这是不行的。</li></ul><p>下面我截两张图再来给你们看看(看完图再看上面的描述，就能理解了)：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16324c6cb5b10a60?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16324c6dda89dc8b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>图片来源和更多的展开阅读</strong>：<a href="https://blog.csdn.net/wangyanguiyiyang/article/details/49800493" target="_blank" rel="noopener">blog.csdn.net/wangyanguiy…</a></p><h1 id="五、wait和notify方法"><a href="#五、wait和notify方法" class="headerlink" title="五、wait和notify方法"></a>五、wait和notify方法</h1><p>wait和notify方法其实就是Java给我们提供让<strong>线程之间通信</strong>的API。</p><p>按照惯例我们还是来看注释怎么说吧：</p><p>wait方法：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16324c6d134d6573?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>notify方法：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16324c6d2ccb71a1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>notifyAll()方法：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16324c6d53677af3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>看完上面的注释我们可以<strong>总结以下的要点</strong>：</p><ul><li><p>无论是wait、notify还是notifyAll()都需要</p><p>由监听器对象(锁对象)来进行调用</p><ul><li>简单来说：<strong>他们都是在同步代码块中调用的</strong>，否则会抛出异常！</li></ul></li><li><p><code>notify()</code>唤醒的是在等待队列的<strong>某个</strong>线程(不确定会唤醒哪个)，<code>notifyAll()</code>唤醒的是等待队列<strong>所有</strong>线程</p></li><li><p>导致</p><pre><code>wait()</code></pre><p>的线程被唤醒可以有4种情况</p><ul><li>该线程被中断</li><li><code>wait()</code>时间到了</li><li>被<code>notify()</code>唤醒</li><li>被<code>notifyAll()</code>唤醒</li></ul></li><li><p>调用<code>wait()</code>的线程会<strong>释放掉锁</strong></p></li></ul><p>其实总结完上面的并不会有比较深刻的印象，可以尝试着回答几个问题来加深对<code>wait()</code>和<code>notify()</code>的理解。</p><h2 id="5-1为什么wait和notify在Object方法上？"><a href="#5-1为什么wait和notify在Object方法上？" class="headerlink" title="5.1为什么wait和notify在Object方法上？"></a>5.1为什么wait和notify在Object方法上？</h2><p>从一开始我们就说了：<code>wait()</code>和<code>notify()</code>是Java给我们提供线程之间通信的API，既然是线程的东西，那什么是在Object类上定义，而不是在Thread类上定义呢？</p><p>因为我们的<strong>锁是对象锁</strong>【要是忘记的同学可回顾：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484198&idx=1&sn=4d8e372165bb49987a6243f17153a9b4&chksm=ebd74227dca0cb31311886f835092c9360d08a9f0a249ece34d4b1e49a31c9ec773fa66c8acc#rd" target="_blank" rel="noopener">Java锁机制了解一下</a>】，每个对象都可以成为锁。<strong>让当前线程等待某个对象的锁，当然应该通过这个对象来操作了</strong>。</p><ul><li>锁对象是<strong>任意</strong>的，所以这些方法必须定义在Object类中</li></ul><h2 id="5-2notify方法调用后，会发生什么？"><a href="#5-2notify方法调用后，会发生什么？" class="headerlink" title="5.2notify方法调用后，会发生什么？"></a>5.2notify方法调用后，会发生什么？</h2><p>上面已经说了，notify会唤醒某个处于等待队列的线程。</p><p>但是要<strong>注意</strong>的是：</p><ul><li>notify方法调用后，被唤醒的线程<strong>不会立马获得到锁对象</strong>。而是等待notify的synchronized代码块<strong>执行完之后</strong>才会获得锁对象</li></ul><h2 id="5-3sleep和wait有什么区别？"><a href="#5-3sleep和wait有什么区别？" class="headerlink" title="5.3sleep和wait有什么区别？"></a>5.3sleep和wait有什么区别？</h2><p><code>Thread.sleep()</code>与<code>Object.wait()</code>二者都可以暂停当前线程，释放CPU控制权。</p><ul><li>主要的区别在于<code>Object.wait()</code>在释放CPU同时，<strong>释放了对象锁的控制</strong>。</li><li>而<code>Thread.sleep()</code>没有对锁释放</li></ul><p>参考资料：</p><ul><li><a href="https://blog.csdn.net/lingzhm/article/details/44940823" target="_blank" rel="noopener">blog.csdn.net/lingzhm/art…</a></li><li><a href="http://www.cnblogs.com/dolphin0520/p/3920385.html" target="_blank" rel="noopener">www.cnblogs.com/dolphin0520…</a></li><li><a href="https://www.cnblogs.com/eer123/p/7880789.html" target="_blank" rel="noopener">www.cnblogs.com/eer123/p/78…</a></li><li><a href="https://www.jianshu.com/p/f4454164c017" target="_blank" rel="noopener">www.jianshu.com/p/f4454164c…</a></li></ul><h1 id="六、finalize-方法"><a href="#六、finalize-方法" class="headerlink" title="六、finalize()方法"></a>六、finalize()方法</h1><p><code>finalize()</code>方法将在<strong>垃圾回收器清除对象之前调用</strong>，但该方法不知道何时调用，具有<strong>不定性</strong></p><ul><li>一般我们都不会重写它~</li></ul><blockquote><p>一个对象的finalize()方法<strong>只会被调用一次</strong>，而且finalize()被调用不意味着gc会立即回收该对象，所以有可能调用finalize()后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会调用finalize()，产生问题。</p></blockquote><p>参考资料：</p><ul><li><a href="https://segmentfault.com/q/1010000000094660" target="_blank" rel="noopener">segmentfault.com/q/101000000…</a></li></ul><p>进阶的资料：</p><ul><li><a href="https://www.cnblogs.com/Smina/p/7189427.html" target="_blank" rel="noopener">www.cnblogs.com/Smina/p/718…</a></li><li><a href="http://www.importnew.com/23913.html" target="_blank" rel="noopener">www.importnew.com/23913.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/29522201" target="_blank" rel="noopener">zhuanlan.zhihu.com/p/29522201</a></li><li><a href="https://zhuanlan.zhihu.com/p/25698745" target="_blank" rel="noopener">zhuanlan.zhihu.com/p/25698745</a></li></ul><h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><p>总的来说也算是把Object看了一遍了，不至于一下子把它的方法给忘了<del>~</del>在学习的过程中也遇到过问题，最明显的是对protected修饰符又加深了一次理解。</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16324c6d5dc7eb99?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>参考资料：</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>软件开发六大设计原则</title>
      <link href="/2020/01/10/ruan-jian-kai-fa-liu-da-she-ji-yuan-ze/"/>
      <url>/2020/01/10/ruan-jian-kai-fa-liu-da-she-ji-yuan-ze/</url>
      
        <content type="html"><![CDATA[<h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><p>定义：软件实体如类、模块和函数应该对扩展开放，对修改关闭。<br>优点：可提高软件系统的可复用性及可维护性<br>举例：一开始需要获取课程的价格，面向接口的开发原则如下</p><pre><code>public interface Course {    Double getPrice();}public class JavaCourse implements Course {    private Double price;    public JavaCourse() {    }    public JavaCourse(Integer id, String name, Double price) {        this.price = price;    }    @Override    public Double getPrice() {        return this.price;    }public class Test {    public static void main(String[] args) {        Course course = new JavaCourse(1,&quot;java&quot;,15.25);        System.out.println(&quot;课程价格&quot;+course.getPrice());    }}}</code></pre><p>后来需求变动，需要显示课程打折后的价格。<br>需要做如下变动：</p><pre><code>public class JavaDiscountCourse extends JavaCourse {    public JavaDiscountCourse(Integer id, String name, Double price) {        super(id, name, price);    }    public Double getDiscountPrice(){        return this.getPrice()*0.8;    }}public class Test {    public static void main(String[] args) {        Course course = new JavaDiscountCourse(1,&quot;java&quot;,15.25);        System.out.println(&quot;课程价格&quot;+course.getPrice()+&quot;\r\n课程折后价格&quot;+((JavaDiscountCourse) course).getDiscountPrice());    }}</code></pre><h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><p>定义：高层模块不应该依赖底层模块，二者都应该依赖其抽象<br>优点：可以减少类之间的耦合性、提高系统稳定性、提高代码可读性和可维护性，可降低修改程序所造成的风险<br>代码举例：</p><pre><code>public interface Course {    void study();}public class PythonCourse implements Course {    @Override    public void study() {        System.out.println(&quot;学习Python课程&quot;);    }}public class Alice {     Course course;     public Alice(Course course){         this.course = course;     }     public void studyCourse(){         course.study();     }}public class Test {    public static void main(String[] args) {        Alice alice = new Alice(new PythonCourse());        alice.studyCourse();    }}</code></pre><p>以上代码通过将PythonCourse的抽象注入Alice中实现了Alice和Course的具体实现的解耦，实现了依赖倒置。</p><h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><p>定义：不要存在多于一个导致类变更的原因<br>优点：降低类的复杂度，提高类的可读性，提高系统的可维护性、降低变更引起的风险<br>理解：一个类只需要实现一类功能，不要有几类功能同时在一个类中，这个微服务的思想有些相似，只是一个微服务需要实现的是一大类功能，目的都是使系统细粒度化，便于开发新功能时写更少的代码（用原有的功能通过不同的调用步骤或顺序或传入不同的参数即可组合出新的功能），也就是便于扩展。</p><h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h1><p>定义：用多个专门的接口，而不使用单一的总接口，客户端不应该依赖他不需要的接口。<br>优点：符合我们常说的高内聚低耦合的设计思想从而使得类具有很好的可读性、可扩展性和可维护性。</p><h1 id="迪米特法则（最少知道原则）"><a href="#迪米特法则（最少知道原则）" class="headerlink" title="迪米特法则（最少知道原则）"></a>迪米特法则（最少知道原则）</h1><p>定义：一个对象应该对其他对象保持最少的了解。<br>优点：降低类之间的耦合。<br>举例：如下类图并不遵循迪米特原则，因为Boss只需要和TeamLeader交互，而不需要和Course产生依赖。<br><img src="/2020/01/10/ruan-jian-kai-fa-liu-da-she-ji-yuan-ze/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%5C1.png" alt="在这里插入图片描述"></p><p>改进后满足迪米特原则类关系如下<br><img src="/2020/01/10/ruan-jian-kai-fa-liu-da-she-ji-yuan-ze/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%5C2.png" alt="在这里插入图片描述"></p><h1 id="里斯替换原则"><a href="#里斯替换原则" class="headerlink" title="里斯替换原则"></a>里斯替换原则</h1><p>定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</p><p>定义2：所有引用基类的地方必须能透明地使用其子类的对象。</p><p>问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</p><p>解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</p><p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p><p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</p><p>举例说明继承的风险，我们需要完成一个两数相减的功能，由类A来负责。</p><p>运行结果：</p><p>100-50=50</p><p>100-80=20</p><p>后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：</p><ul><li>两数相减。</li><li>两数相加，然后再加100。</li></ul><p>由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：</p><p>类B完成后，运行结果：</p><p>100-50=150</p><p>100-80=180</p><p>100+20+100=220</p><p>我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</p><p>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li><li>子类中可以增加自己特有的方法。</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ul><p>看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？</p><p>后果就是：你写的代码出问题的几率将会大大增加。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JSP</title>
      <link href="/2020/01/09/shen-ru-li-jie-jsp/"/>
      <url>/2020/01/09/shen-ru-li-jie-jsp/</url>
      
        <content type="html"><![CDATA[<h4 id="JSP介绍"><a href="#JSP介绍" class="headerlink" title="JSP介绍"></a>JSP介绍</h4><p> JSP（Java server page）是Java EE规范最基本成员，他是Java Web开发的重点知识，虽然我们一直在用，但其原理知之甚少。今天重点研究一些JSP核心内容以及其工作原理。</p><p>  JSP和Servlet的本质是一样的，因为JSP最终需要编译成Servlet才能运行，换句话说JSP是生成Servler的草稿文件。</p><p>  JSP比较简单，就是在HTML中嵌入Java代码，或者使用JSP标签，包括使用用户自定义标签，从而可以动态的提供内容。早起JSP应用比较广泛，一个web应用可以全部由JSP页面组成，只需要少量的JavaBean即可，但是这样导致了JSP职责过于复杂，这是Java EE标准的出现无疑是雪中送炭，因此JSP慢慢发展成单一的表现技术，不再承担业务逻辑组件以及持久层组件的责任。</p><h4 id="JSP基本原理"><a href="#JSP基本原理" class="headerlink" title="JSP基本原理"></a>JSP基本原理</h4><p>  JSP的本质是servlet，当用户指定servlet发送请求时，servlet利用输出流动态生成HTML页面。由于包含大量的HTML标签。静态文本等格式导致servlet的开发效率极低，所有的表现逻辑，包括布局、色彩及图像等，都必须耦合在Java代码中，静态的部分无需Java程序控制，只有那些需要从数据库读取或者需要动态生成的页面内容才使用Java脚本控制。</p><h4 id="JSP和Servlet是什么关系"><a href="#JSP和Servlet是什么关系" class="headerlink" title="JSP和Servlet是什么关系?"></a>JSP和Servlet是什么关系?</h4><p>　　Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图(view)而Servlet适合充当控制器(controller)。</p><h4 id="JSP中的四种作用域"><a href="#JSP中的四种作用域" class="headerlink" title="JSP中的四种作用域"></a>JSP中的四种作用域</h4><p>JSP中的四种作用域包括page、request、session和application，具体来说：</p><ul><li>page代表与一个页面相关的对象和属性。</li><li>request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件;需要在页面显示的临时数据可以置于此作用域。</li><li>session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li><li>application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li></ul><h4 id="实现会话跟踪的技术"><a href="#实现会话跟踪的技术" class="headerlink" title="实现会话跟踪的技术"></a>实现会话跟踪的技术</h4><p>　　由于HTTP协议本身是无状态的，服务器为了区分不同的用户，就需要对用户会话进行跟踪，简单的说就是为用户进行登记，为用户分配唯一的ID，下一次用户在请求中包含此ID，服务器据此判断到底是哪一个用户。</p><p>　　1)URL 重写：在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。</p><p>　　2) 设置表单隐藏域：将和会话跟踪相关的字段添加到隐式表单域中，这些信息不会在浏览器中显示但是提交表单时会提交给服务器。</p><p>　　这两种方式很难处理跨越多个页面的信息传递，因为如果每次都要修改URL或在页面中添加隐式表单域来存储用户会话相关信息，事情将变得非常麻烦。</p><p>　　3)cookie：cookie有两种，一种是基于窗口的，浏览器窗口关闭后，cookie就没有了;另一种是将信息存储在一个临时文件中，并设置存在的时间。当用户通过浏览器和服务器建立一次会话后，会话ID就会随响应信息返回存储在基于窗口的cookie中，那就意味着只要浏览器没有关闭，会话没有超时，下一次请求时这个会话ID又会提交给服务器让服务器识别用户身份。会话中可以为用户保存信息。会话对象是在服务器内存中的，而基于窗口的cookie是在客户端内存中的。如果浏览器禁用了cookie，那么就需要通过下面两种方式进行会话跟踪。当然，在使用cookie时要注意几点：首先不要在cookie中存放敏感信息;其次cookie存储的数据量有限(4k)，不能将过多的内容存储cookie中;再者浏览器通常只允许一个站点最多存放20个cookie。当然，和用户会话相关的其他信息(除了会话ID)也可以存在cookie方便进行会话跟踪。</p><p>　　4)HttpSession：在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。</p><h4 id="过滤器作用和用法"><a href="#过滤器作用和用法" class="headerlink" title="过滤器作用和用法"></a>过滤器作用和用法</h4><p>　　Java Web开发中的过滤器(filter)是从Servlet 2.3规范开始增加的功能，并在Servlet 2.4规范中得到增强。对Web应用来说，过滤器是一个驻留在服务器端的Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。当Web容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联。如果有，那么容器将把请求交给过滤器进行处理。在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，在过滤器中你可以对响应的内容进行转换，然后再将响应发送到客户端。</p><p>　　常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对XML的输出应用XSLT等。</p><p>　　过滤器相关的接口主要有：Filter、FilterConfig和FilterChain。</p><p>　　监听器有哪些作用和用法?</p><p>　　Java Web开发中的监听器(listener)就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示：</p><p>　　ServletContextListener：对Servlet上下文的创建和销毁进行监听。</p><p>　　ervletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。</p><p>　　HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听。</p><p>　　ServletRequestListener：对请求对象的初始化和销毁进行监听。</p><p>　　ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。</p><p>　　HttpSessionListener：对Session的创建和销毁进行监听。</p><p>　　补充： session的销毁有两种情况：</p><p>　　session超时(可以在web.xml中通过/标签配置超时时间);</p><p>　　通过调用session对象的invalidate()方法使session失效。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis简单使用总结</title>
      <link href="/2020/01/08/redis-jian-dan-shi-yong-zong-jie/"/>
      <url>/2020/01/08/redis-jian-dan-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。</p><p>键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p><p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p><h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><table><thead><tr><th>数据类型</th><th>可以存储的值</th><th>操作</th></tr></thead><tbody><tr><td>STRING</td><td>字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作对整数和浮点数执行自增或者自减操作</td></tr><tr><td>LIST</td><td>列表</td><td>从两端压入或者弹出元素 对单个或者多个元素进行修剪，只保留一个范围内的元素</td></tr><tr><td>SET</td><td>无序集合</td><td>添加、获取、移除单个元素检查一个元素是否存在于集合中计算交集、并集、差集从集合里面随机获取元素</td></tr><tr><td>HASH</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对获取所有键值对检查某个键是否存在</td></tr><tr><td>ZSET</td><td>有序集合</td><td>添加、获取、删除元素根据分值范围或者成员来获取元素计算一个键的排名</td></tr></tbody></table><blockquote><p><a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/" target="_blank" rel="noopener">What Redis data structures look like</a></p></blockquote><h2 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h2><p><a href="https://camo.githubusercontent.com/741c9153e1c49eeec9f29ea80a06bf444a767903/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36303139623264622d626333652d343430382d623664382d3936303235663434383164362e706e67" target="_blank" rel="noopener"><img src="/2020/01/08/redis-jian-dan-shi-yong-zong-jie/D:%5CMyBlot%5Cbolt%5Csource_posts%5Credis%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%5C1.png" alt="img"></a></p><pre><code>&gt; set hello worldOK&gt; get hello&quot;world&quot;&gt; del hello(integer) 1&gt; get hello(nil)</code></pre><h2 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h2><p><a href="https://camo.githubusercontent.com/f6a0fffb6f97f71425a2d839fcc0f93b7042446e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66623332373631312d376532622d346632662d396635622d3338353932643430386630372e706e67" target="_blank" rel="noopener"><img src="/2020/01/08/redis-jian-dan-shi-yong-zong-jie/D:%5CMyBlot%5Cbolt%5Csource_posts%5Credis%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%5C2.png" alt="img"></a></p><pre><code>&gt; rpush list-key item(integer) 1&gt; rpush list-key item2(integer) 2&gt; rpush list-key item(integer) 3&gt; lrange list-key 0 -11) &quot;item&quot;2) &quot;item2&quot;3) &quot;item&quot;&gt; lindex list-key 1&quot;item2&quot;&gt; lpop list-key&quot;item&quot;&gt; lrange list-key 0 -11) &quot;item2&quot;2) &quot;item&quot;</code></pre><h2 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h2><p><a href="https://camo.githubusercontent.com/ee95c32da9c5a0d4d6b69514b4bf9290dea36b6e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63643566626366662d336633352d343361362d386666612d3038326139336365306630652e706e67" target="_blank" rel="noopener"><img src="/2020/01/08/redis-jian-dan-shi-yong-zong-jie/D:%5CMyBlot%5Cbolt%5Csource_posts%5Credis%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%5C3.png" alt="img"></a></p><pre><code>&gt; sadd set-key item(integer) 1&gt; sadd set-key item2(integer) 1&gt; sadd set-key item3(integer) 1&gt; sadd set-key item(integer) 0&gt; smembers set-key1) &quot;item&quot;2) &quot;item2&quot;3) &quot;item3&quot;&gt; sismember set-key item4(integer) 0&gt; sismember set-key item(integer) 1&gt; srem set-key item2(integer) 1&gt; srem set-key item2(integer) 0&gt; smembers set-key1) &quot;item&quot;2) &quot;item3&quot;</code></pre><h2 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h2><p><a href="https://camo.githubusercontent.com/2a3754a8770f890d0e53d8bb7ccf446f384c33ae/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37626432303261372d393364342d346633612d613837382d6166363861653235353339612e706e67" target="_blank" rel="noopener"><img src="/2020/01/08/redis-jian-dan-shi-yong-zong-jie/D:%5CMyBlot%5Cbolt%5Csource_posts%5Credis%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%5C4.png" alt="img"></a></p><pre><code>&gt; hset hash-key sub-key1 value1(integer) 1&gt; hset hash-key sub-key2 value2(integer) 1&gt; hset hash-key sub-key1 value1(integer) 0&gt; hgetall hash-key1) &quot;sub-key1&quot;2) &quot;value1&quot;3) &quot;sub-key2&quot;4) &quot;value2&quot;&gt; hdel hash-key sub-key2(integer) 1&gt; hdel hash-key sub-key2(integer) 0&gt; hget hash-key sub-key1&quot;value1&quot;&gt; hgetall hash-key1) &quot;sub-key1&quot;2) &quot;value1&quot;</code></pre><h2 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h2><p><a href="https://camo.githubusercontent.com/f547165de432ff22e18fd007b393b24540465abe/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31323032623264362d393436392d343235312d626434372d6361363033346662363131362e706e67" target="_blank" rel="noopener"><img src="/2020/01/08/redis-jian-dan-shi-yong-zong-jie/D:%5CMyBlot%5Cbolt%5Csource_posts%5Credis%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%5C5.png" alt="img"></a></p><pre><code>&gt; zadd zset-key 728 member1(integer) 1&gt; zadd zset-key 982 member0(integer) 1&gt; zadd zset-key 982 member0(integer) 0&gt; zrange zset-key 0 -1 withscores1) &quot;member1&quot;2) &quot;728&quot;3) &quot;member0&quot;4) &quot;982&quot;&gt; zrangebyscore zset-key 0 800 withscores1) &quot;member1&quot;2) &quot;728&quot;&gt; zrem zset-key member1(integer) 1&gt; zrem zset-key member1(integer) 0&gt; zrange zset-key 0 -1 withscores1) &quot;member0&quot;2) &quot;982&quot;</code></pre><h1 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h1><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>可以对 String 进行自增自减运算，从而实现计数器功能。</p><p>Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p><h2 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h2><p>例如 DNS 记录就很适合使用 Redis 进行存储。</p><p>查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息</p><p>不过最好使用 Kafka、RabbitMQ 等消息中间件。</p><h2 id="会话缓存"><a href="#会话缓存" class="headerlink" title="会话缓存"></a>会话缓存</h2><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。</p><p>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p><h2 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h2><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。</p><p>可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。</p><p>ZSet 可以实现有序性操作，从而实现排行榜等功能。</p>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM必须知道的基础</title>
      <link href="/2020/01/07/jvm-bi-xu-zhi-dao-de-ji-chu/"/>
      <url>/2020/01/07/jvm-bi-xu-zhi-dao-de-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>网上有很多描述JVM内存区的图,我觉得这张能表述内容较多</p><p><img src="/2020/01/07/jvm-bi-xu-zhi-dao-de-ji-chu/JVM%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E5%9F%BA%E7%A1%80%5C1.png" alt="img"></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><pre><code> 程序计数器(Program Counter Register)存储当前线程执行的字节码行号，占用内存较小。字节码解释器就是通过这个计数器的值来选择下一条需要执行的字节码指令。执行Java方法时计数器指向正在执行的虚拟字节码指令的地址，执行Native方法时指向空。</code></pre><h4 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h4><pre><code>java虚拟机栈（Java Virtual Machine Stack）与程序计数器一样，也是线程私有的，生命周期与线程相同。java虚拟机栈描述的是java方法执行的内存模型,每个方法执行的时候都会创建一个栈帧,用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法的调用和结束分别对应栈帧的入栈和出栈。</code></pre><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><pre><code>本地方法栈（Native Method Stack）与java虚拟机栈作用相似,java虚拟机栈是为java方法服务,本地方法栈是为Native方法服务,甚至有些虚拟机实现时直接将两者合而为一(如:HotSpot).</code></pre><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><pre><code>Java堆(Java Heap)是虚拟机管理的内存中最大的一块，该内存区域的唯一目的就是存放对象实例。java堆是垃圾收集区域管理的主要区域。从回收的角度看，可以细分为新生代和老年代；再细致一点就是Eden空间、From Survivor空间、To Survivor空间。线程共享的java堆能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。</code></pre><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><pre><code>方法区（Method Area）与java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码数据等。这个区域的垃圾回收主要是针对常量池的回收和对类型的卸载。</code></pre><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><pre><code>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件的常量池(Constant Pool Table)将在类加载后进入方法区的运行时常量池存放。除此之外，还会将翻译出来的直接引用也存放在运行时常量池。运行期间也可以将新的常量放入运行时常量池。</code></pre><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><pre><code>直接内存(Direct Memory)并不是java虚拟机运行时数据区的一部分。在JDK1.4中新加入了NIO（New Input/Output）类,引入了一种基于通道(channel)和缓冲区(Buffer)的I/O方式.他可以使用Native函数库直接分配对外内存.然后通过一个内存在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作.</code></pre><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><h3 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p><p>在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p><h4 id="可达性分析算"><a href="#可达性分析算" class="headerlink" title="可达性分析算"></a>可达性分析算</h4><p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</p><p>Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：</p><ul><li>虚拟机栈中局部变量表中引用的对象</li><li>本地方法栈中 JNI 中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><h4 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h4><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p><p>主要是对常量池的回收和对类的卸载。</p><p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p><p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p><ul><li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li></ul><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h4><p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p><p>Java 提供了四种强度不同的引用类型。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>被强引用关联的对象不会被回收。</p><p>使用 new 一个新对象的方式来创建强引用。</p><pre><code>Object obj = new Object();</code></pre><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p><p>使用 SoftReference 类来创建软引用。</p><pre><code>Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null;  // 使对象只被软引用关联</code></pre><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p>使用 WeakReference 类来创建弱引用。</p><pre><code>Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null;</code></pre><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p><p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p><p>使用 PhantomReference 来创建虚引用。</p><pre><code>Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);obj = null;</code></pre><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="1-标记-清除"><a href="#1-标记-清除" class="headerlink" title="1. 标记 - 清除"></a>1. 标记 - 清除</h4><p>顾名思义，标记-清除算法分为两个阶段，标记(mark)和清除(sweep).</p><p>在标记阶段，collector从mutator根对象开始进行遍历，对从mutator根对象可以访问到的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象。</p><p>而在清除阶段，collector对堆内存(heap memory)从头到尾进行线性的遍历，如果发现某个对象没有标记为可达对象-通过读取对象的header信息，则就将其回收。</p><p><img src="/2020/01/07/jvm-bi-xu-zhi-dao-de-ji-chu/JVM%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E5%9F%BA%E7%A1%80%5C2.png" alt="img"></p><p>从上图我们可以看到，在Mark阶段，从根对象1可以访问到B对象，从B对象又可以访问到E对象，所以B,E对象都是可达的。同理，F,G,J,K也都是可达对象。到了Sweep阶段，所有非可达对象都会被collector回收。同时，Collector在进行标记和清除阶段时会将整个应用程序暂停(mutator)，等待标记清除结束后才会恢复应用程序的运行。</p><ul><li><p><strong>优点</strong>：</p><p>实现简单，不需要进行对象进行移动。</p></li><li><p><strong>缺点</strong>：</p><p>标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。</p></li></ul><h4 id="2-标记-整理"><a href="#2-标记-整理" class="headerlink" title="2. 标记 - 整理"></a>2. 标记 - 整理</h4><p>其中标记阶段跟标记-清除算法中的标记阶段是一样的，而对于整理阶段，它的工作就是移动所有的可达对象到堆内存的同一个区域中，使他们紧凑的排列在一起，从而将所有 <strong>非可达对象释放出来的空闲内存</strong> 都集中在一起，通过这样的方式来达到减少内存碎片的目的。</p><p><img src="/2020/01/07/jvm-bi-xu-zhi-dao-de-ji-chu/JVM%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E5%9F%BA%E7%A1%80%5C3.png" alt="3"></p><ul><li><p><strong>优点</strong>：</p><p>解决了标记-清理算法存在的内存碎片问题。</p></li><li><p><strong>缺点</strong>：</p><p>仍需要进行局部对象移动，一定程度上降低了效率。</p></li></ul><h4 id="3-复制"><a href="#3-复制" class="headerlink" title="3. 复制"></a>3. 复制</h4><p>这种收集算法解决了标记清除算法存在的效率问题。它将内存区域划分成相同的两个<strong>内存块</strong>。每次仅使用一半的空间，<code>JVM</code>生成的新对象放在一半空间中。当一半空间用完时进行<code>GC</code>，把可到达对象复制到另一半空间，然后把使用过的内存空间一次清理掉。</p><ul><li><p><strong>优点</strong>：</p><p>按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</p></li><li><p><strong>缺点</strong>：</p><p>可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</p></li></ul><h4 id="4-分代收集"><a href="#4-分代收集" class="headerlink" title="4. 分代收集"></a>4. 分代收集</h4><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p><p>一般将堆分为新生代和老年代。</p><ul><li>对于<strong>新生代</strong>，每次<code>GC</code>时都有<strong>大量</strong>的对象死亡，只有<strong>少量</strong>对象存活。考虑到复制成本低，适合采用<strong>复制算法</strong>。因此有了<code>From Survivor</code>和<code>To Survivor</code>区域。</li><li>对于<strong>老年代</strong>，因为对象<strong>存活率高</strong>，没有额外的内存空间对它进行担保。因而适合采用<strong>标记-清理算法</strong>和<strong>标记-整理算法</strong>进行回收。</li></ul><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="/2020/01/07/jvm-bi-xu-zhi-dao-de-ji-chu/JVM%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E5%9F%BA%E7%A1%80%5C4.png" alt="img"></p><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><ul><li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li><li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ul><h4 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h4><p><img src="/2020/01/07/jvm-bi-xu-zhi-dao-de-ji-chu/JVM%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E5%9F%BA%E7%A1%80%5C5.png" alt="img"></p><p>Serial 翻译为串行，也就是说它以串行的方式执行。</p><p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p><p>它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p><p>它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p><h4 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2. ParNew 收集器"></a>2. ParNew 收集器</h4><p><a href="https://camo.githubusercontent.com/573a3abc71931daef42e0b42b1876cbe4f940cdc/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38313533386364352d316263662d346533312d383665352d6531393864663165303133622e6a7067" target="_blank" rel="noopener"><img src="/2020/01/07/jvm-bi-xu-zhi-dao-de-ji-chu/JVM%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E5%9F%BA%E7%A1%80%5C7.png" alt="img"></a></p><p>它是 Serial 收集器的多线程版本。</p><p>它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</p><h4 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3. Parallel Scavenge 收集器"></a>3. Parallel Scavenge 收集器</h4><p>与 ParNew 一样是多线程收集器。</p><p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p><p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p><p>可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p><h4 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4. Serial Old 收集器"></a>4. Serial Old 收集器</h4><p><img src="/2020/01/07/jvm-bi-xu-zhi-dao-de-ji-chu/JVM%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E5%9F%BA%E7%A1%80%5C13.png" alt="13"></p><p>是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p><ul><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li></ul><h4 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5. Parallel Old 收集器"></a>5. Parallel Old 收集器<img src="/2020/01/07/jvm-bi-xu-zhi-dao-de-ji-chu/JVM%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E5%9F%BA%E7%A1%80%5C8.png" alt="img"></h4><p>是 Parallel Scavenge 收集器的老年代版本。</p><p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p><h4 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6. CMS 收集器"></a>6. CMS 收集器</h4><p><img src="/2020/01/07/jvm-bi-xu-zhi-dao-de-ji-chu/JVM%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E5%9F%BA%E7%A1%80%5C9.png" alt="img"></p><p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</p><p>分为以下四个流程：</p><ul><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ul><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p>具有以下缺点：</p><ul><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul><h4 id="7-G1-收集器"><a href="#7-G1-收集器" class="headerlink" title="7. G1 收集器"></a>7. G1 收集器</h4><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p><p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。<img src="/2020/01/07/jvm-bi-xu-zhi-dao-de-ji-chu/JVM%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E5%9F%BA%E7%A1%80%5C10.png" alt="img"></p><p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p><p><a href="https://camo.githubusercontent.com/5049da1b34969b272be2bffc6c6de0206b33253c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39626264646565622d653933392d343166302d386538652d3262316130616137653061372e706e67" target="_blank" rel="noopener"><img src="/2020/01/07/jvm-bi-xu-zhi-dao-de-ji-chu/JVM%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E5%9F%BA%E7%A1%80%5C11.png" alt="img"></a></p><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><p><a href="https://camo.githubusercontent.com/5bd72d589ead80c22547e3288a9a406241a1fb6b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66393965653737312d633536662d343766622d393134382d6330303336363935623566652e6a7067" target="_blank" rel="noopener"><img src="/2020/01/07/jvm-bi-xu-zhi-dao-de-ji-chu/JVM%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E5%9F%BA%E7%A1%80%5C12.png" alt="img"></a></p><p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p>具备如下特点：</p><ul><li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h3><ul><li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li><li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li></ul><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><h4 id="1-对象优先在-Eden-分配"><a href="#1-对象优先在-Eden-分配" class="headerlink" title="1. 对象优先在 Eden 分配"></a>1. 对象优先在 Eden 分配</h4><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p><h4 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h4><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p><p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p><h4 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3. 长期存活的对象进入老年代"></a>3. 长期存活的对象进入老年代</h4><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p><p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p><h4 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h4><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p><h4 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h4><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p><p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p><h3 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h3><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p><h4 id="1-调用-System-gc"><a href="#1-调用-System-gc" class="headerlink" title="1. 调用 System.gc()"></a>1. 调用 System.gc()</h4><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><h4 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h4><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p><p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><h4 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3. 空间分配担保失败"></a>3. 空间分配担保失败</h4><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。</p><h4 id="4-JDK-1-7-及以前的永久代空间不足"><a href="#4-JDK-1-7-及以前的永久代空间不足" class="headerlink" title="4. JDK 1.7 及以前的永久代空间不足"></a>4. JDK 1.7 及以前的永久代空间不足</h4><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p><p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p><h4 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5. Concurrent Mode Failure"></a>5. Concurrent Mode Failure</h4><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p><h2 id="类加载机制概念"><a href="#类加载机制概念" class="headerlink" title="类加载机制概念"></a>类加载机制概念</h2><ul><li>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。*Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数，属性和方法等，Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能,这里就是我们经常能见到的Class类。</li></ul><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="/2020/01/07/jvm-bi-xu-zhi-dao-de-ji-chu/JVM%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E5%9F%BA%E7%A1%80%5C6.png" alt="img"></p><p>工作机制</p><p>类装载器就是寻找类的字节码文件，并构造出类在JVM内部表示的对象组件。在Java中，类装载器把一个类装入JVM中，要经过以下步骤：</p><pre><code>  (1) 装载：查找和导入Class文件；  (2) 链接：把类的二进制数据合并到JRE中；     (a)校验：检查载入Class文件数据的正确性；     (b)准备：给类的静态变量分配存储空间；     (c)解析：将符号引用转成直接引用；  (3) 初始化：对类的静态变量，静态代码块执行初始化操作</code></pre><p>Java程序可以动态扩展是由运行期动态加载和动态链接实现的；比如：如果编写一个使用接口的应用程序，可以等到运行时再指定其实际的实现(多态)，解析过程有时候还可以在初始化之后执行；比如：动态绑定(多态)如上图所示，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这个顺序来按部就班地开始，而解析阶段则不一定，它在某些情况下可以在初始化阶段后再开始。类的生命周期的每一个阶段通常都是互相交叉混合式进行的，通常会在一个阶段执行的过程中调用或激活另外一个阶段。</p><h4 id="装载-加载"><a href="#装载-加载" class="headerlink" title="装载(加载)"></a>装载(加载)</h4><p>类的装载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的<strong>方法区</strong>内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><p>加载.class文件的方式有:</p><p>1). 从本地系统中直接加载2). 通过网络下载.class文件3). 从zip，jar等归档文件中加载.class文件4). 从专有数据库中提取.class文件5). 将Java源文件动态编译为.class文件</p><p>在了解了什么是类的加载后，回头来再看jvm进行类加载阶段都做了什么。虚拟机需要完成以下三件事情：</p><p>1).通过一个类的全限定名称来获取定义此类的二进制字节流。</p><p>2).将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p><p>3).在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。</p><p>相对于类加载过程的其他阶段，加载阶段是开发期相对来说可控性比较强，该阶段既可以使用系统提供的类加载器完成，也可以由用户自定义的类加载器来完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。关于这个过程的更多细节，我会在下一节细说，类的加载。加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h4><p>验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。</p><p>1）文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。</p><p>2）元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。</p><p>3）字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</p><p>4）符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。注：</p><p>1）这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p><p>2）这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经在内存中。</p><p>直接引用（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。</p><p>1)、类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。</p><p>2)、字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。</p><p>3)、类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。</p><p>4)、接口方法解析：与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。</p><p><strong>5. 初始化</strong></p><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了加载（Loading）阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><p>①声明类变量时指定初始值</p><p>②使用静态代码块为类变量指定初始值</p><p>JVM初始化步骤</p><p>1)、假如这个类还没有被加载和连接，则程序先加载并连接该类</p><p>2)、假如该类的直接父类还没有被初始化，则先初始化其直接父类</p><p>3)、假如类中有初始化语句，则系统依次执行这些初始化语句</p><p>初始化阶段时执行类构造器方法()的过程。</p><p>1）类构造器方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序所决定。</p><p>2）类构造器方法与类的构造函数不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的类构造器方法执行之前，父类的类构造器方法已经执行完毕，因此在虚拟机中第一个执行的类构造器方法的类一定是java.lang.Object。</p><p>3）由于父类的类构造器方法方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</p><p>4）类构造器方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块也没有对变量的赋值操作，那么编译器可以不为这个类生成类构造器方法。</p><p>5）接口中可能会有变量赋值操作，因此接口也会生成类构造器方法。但是接口与类不同，执行接口的类构造器方法不需要先执行父接口的类构造器方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也不会执行接口的类构造器方法。</p><p>6）虚拟机会保证一个类的类构造器方法在多线程环境中被正确地加锁和同步。如果有多个线程去同时初始化一个类，那么只会有一个线程去执行这个类的类构造器方法，其它线程都需要阻塞等待，直到活动线程执行类构造器方法完毕。如果在一个类的类构造器方法中有耗时很长的操作，那么就可能造成多个进程阻塞。</p><p><strong>6.结束生命周期</strong></p><p>在以下情况的时候，Java虚拟机会结束生命周期1). 执行了System.exit()方法2). 程序正常执行结束3). 程序在执行过程中遇到了异常或错误而异常终止4). 由于操作系统出现错误而导致Java虚拟机进程终止</p><h3 id="何时开始类的初始化"><a href="#何时开始类的初始化" class="headerlink" title="何时开始类的初始化"></a>何时开始类的初始化</h3><p>什么情况下需要开始类加载过程的第一个阶段:”加载”。虚拟机规范中并没强行约束，这点可以交给虚拟机的的具体实现自由把握，但是对于初始化阶段虚拟机规范是严格规定了如下几种情况，如果类未初始化会对类进行初始化。</p><p>1、创建类的实例</p><p>2、访问类的静态变量(除常量【被final修辞的静态变量】原因:常量一种特殊的变量，因为编译器把他们当作值(value)而不是域(field)来对待。如果你的代码中用到了常变量(constant variable)，编译器并不会生成字节码来从对象中载入域的值，而是直接把这个值插入到字节码中。这是一种很有用的优化，但是如果你需要改变final域的值那么每一块用到那个域的代码都需要重新编译。</p><p>3、访问类的静态方法</p><p>4、反射如(Class.forName(“my.xyz.Test”))</p><p>5、当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化</p><p>6、虚拟机启动时，定义了main()方法的那个类先初始化</p><p>以上情况称为称对一个类进行“主动引用”，除此种情况之外，均不会触发类的初始化，称为“被动引用”接口的加载过程与类的加载过程稍有不同。接口中不能使用static{}块。当一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有真正在使用到父接口时（例如引用接口中定义的常量）才会初始化。</p><h4 id="被动引用例子"><a href="#被动引用例子" class="headerlink" title="被动引用例子"></a><strong>被动引用例子</strong></h4><p>1、子类调用父类的静态变量，子类不会被初始化。只有父类被初始化。。对于静态字段，只有直接定义这个字段的类才会被初始化.</p><p>2、通过数组定义来引用类，不会触发类的初始化</p><p>3、 访问类的常量，不会初始化类</p><pre><code>class SuperClass {      static {          System.out.println(&quot;superclass init&quot;);      }      public static int value = 123;  }  class SubClass extends SuperClass {      static {          System.out.println(&quot;subclass init&quot;);      }  }  public class Test {      public static void main(String[] args) {          System.out.println(SubClass.value);// 被动应用1          SubClass[] sca = new SubClass[10];// 被动引用2      }  }  复制代码</code></pre><p>程序运行输出    superclass init123从上面的输入结果证明了被动引用1与被动引用2</p><pre><code>class ConstClass {      static {          System.out.println(&quot;ConstClass init&quot;);      }      public static final String HELLOWORLD = &quot;hello world&quot;;  }  public class Test {      public static void main(String[] args) {          System.out.println(ConstClass.HELLOWORLD);// 调用类常量      }  }  复制代码</code></pre><p>程序输出结果hello world从上面的输出结果证明了被动引用3</p><p>** 题目分析**</p><p>上面很详细的介绍了类的加载时机和类的加载过程，通过上面的理论来分析本文开门见上的题目</p><pre><code>class SingleTon {      private static SingleTon singleTon = new SingleTon();      public static int count1;      public static int count2 = 0;      private SingleTon() {          count1++;          count2++;      }      public static SingleTon getInstance() {          return singleTon;      }  }  public class Test {      public static void main(String[] args) {          SingleTon singleTon = SingleTon.getInstance();          System.out.println(&quot;count1=&quot; + singleTon.count1);          System.out.println(&quot;count2=&quot; + singleTon.count2);      }  }  复制代码</code></pre><p>分析:</p><p>1:SingleTon singleTon = SingleTon.getInstance();调用了类的SingleTon调用了类的静态方法，触发类的初始化</p><p>2:类加载的时候在准备过程中为类的静态变量分配内存并初始化默认值 singleton=null count1=0,count2=0</p><p>3:类初始化化，为类的静态变量赋值和执行静态代码快。singleton赋值为new SingleTon()调用类的构造方法</p><p>4:调用类的构造方法后count=1;count2=1</p><p>5:继续为count1与count2赋值,此时count1没有赋值操作,所有count1为1,但是count2执行赋值操作就变为0</p><h3 id="类初始化顺序"><a href="#类初始化顺序" class="headerlink" title="类初始化顺序"></a>类初始化顺序</h3><p>现在我们知道什么时候触发类的初始化了，他精确地写在Java语言规范中。但了解清楚 域（fields，静态的还是非静态的）、块（block静态的还是非静态的）、不同类（子类和超类）和不同的接口（子接口，实现类和超接口）的初始化顺序也很重要类。事实上很多核心Java面试题和SCJP问题都是基于这些概念，下面是类初始化的一些规则：</p><pre><code>1.类从顶至底的顺序初始化，所以声明在顶部的字段的早于底部的字段初始化2.超类早于子类和衍生类的初始化3.如果类的初始化是由于访问静态域而触发，那么只有声明静态域的类才被初始化，而不会触发超类的初始化或者子类的4.初始化即使静态域被子类或子接口或者它的实现类所引用。5.接口初始化不会导致父接口的初始化。6.静态域的初始化是在类的静态初始化期间，非静态域的初始化时在类的实例创建期间。这意味这静态域初始化在非静态域之前。7.非静态域通过构造器初始化，子类在做任何初始化之前构造器会隐含地调用父类的构造器，他保证了非静态或实例变量（父类）初始化早于子类复制代码</code></pre><p>原文链接：</p><p>类加载举例：<a href="http://blog.csdn.net/mrzhoug/article/details/51581994" target="_blank" rel="noopener">http://blog.csdn.net/mrzhoug/article/details/51581994</a></p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>JVM设计者把类加载阶段中的“通过’类全名’来获取定义此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a><strong>类与类加载器</strong></h4><p>对于任何一个类，都需要由加载它的类加载器和这个类来确立其在JVM中的唯一性。也就是说，两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等。</p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a><strong>双亲委派模型</strong></h4><p>从虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），该类加载器使用C++语言实现，属于虚拟机自身的一部分。另外一种就是所有其它的类加载器，这些类加载器是由Java语言实现，独立于JVM外部，并且全部继承自抽象类java.lang.ClassLoader。</p><p>从Java开发人员的角度来看，大部分Java程序一般会使用到以下三种系统提供的类加载器：</p><p>1)启动类加载器（Bootstrap ClassLoader）：负责加载JAVA_HOME\lib目录中并且能被虚拟机识别的类库到JVM内存中，如果名称不符合的类库即使放在lib目录中也不会被加载。该类加载器无法被Java程序直接引用。</p><p>2)扩展类加载器（Extension ClassLoader）：该加载器主要是负责加载JAVA_HOME\lib\，该加载器可以被开发者直接使用。</p><p>3)应用程序类加载器（Application ClassLoader）：该类加载器也称为系统类加载器，它负责加载用户类路径（Classpath）上所指定的类库，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>我们的应用程序都是由这三类加载器互相配合进行加载的，我们也可以加入自己定义的类加载器。这些类加载器之间的关系如下图所示：</p><p>如上图所示的类加载器之间的这种层次关系，就称为类加载器的双亲委派模型（Parent Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。</p><p>双亲委派模型的工作过程为：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。</p><p>使用这种模型来组织类加载器之间的关系的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如java.lang.Object类，无论哪个类加载器去加载该类，最终都是由启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。否则的话，如果不使用该模型的话，如果用户自定义一个java.lang.Object类且存放在classpath中，那么系统中将会出现多个Object类，应用程序也会变得很混乱。如果我们自定义一个rt.jar中已有类的同名Java类，会发现JVM可以正常编译，但该类永远无法被加载运行。在rt.jar包中的java.lang.ClassLoader类中，我们可以查看类加载实现过程的代码，具体源码如下：</p><pre><code>protected synchronized Class loadClass(String name, boolean resolve)          throws ClassNotFoundException {      // 首先检查该name指定的class是否有被加载      Class c = findLoadedClass(name);      if (c == null) {          try {              if (parent != null) {                  // 如果parent不为null，则调用parent的loadClass进行加载                  c = parent.loadClass(name, false);              } else {                  // parent为null，则调用BootstrapClassLoader进行加载                  c = findBootstrapClass0(name);              }          } catch (ClassNotFoundException e) {              // 如果仍然无法加载成功，则调用自身的findClass进行加载              c = findClass(name);          }      }      if (resolve) {          resolveClass(c);      }      return c;  }  复制代码</code></pre><p>通过上面代码可以看出，双亲委派模型是通过loadClass()方法来实现的，根据代码以及代码中的注释可以很清楚地了解整个过程其实非常简单：先检查是否已经被加载过，如果没有则调用父加载器的loadClass()方法，如果父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，则先抛出ClassNotFoundException，然后再调用自己的findClass()方法进行加载。</p><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a><strong>自定义类加载器</strong></h4><p>若要实现自定义类加载器，只需要继承java.lang.ClassLoader 类，并且重写其findClass()方法即可。java.lang.ClassLoader 类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class 类的一个实例。除此之外，ClassLoader 还负责加载 Java 应用所需的资源，如图像文件和配置文件等，ClassLoader 中与加载类相关的方法如下：</p><p>方法说明getParent()  返回该类加载器的父类加载器。</p><p>loadClass(String name) 加载名称为 二进制名称为name 的类，返回的结果是 java.lang.Class 类的实例。</p><p>findClass(String name) 查找名称为 name 的类，返回的结果是 java.lang.Class 类的实例。</p><p>findLoadedClass(String name) 查找名称为 name 的已经被加载过的类，返回的结果是 java.lang.Class 类的实例。</p><p>resolveClass(Class&lt;?&gt; c) 链接指定的 Java 类。</p><p>注意：在JDK1.2之前，类加载尚未引入双亲委派模式，因此实现自定义类加载器时常常重写loadClass方法，提供双亲委派逻辑，从JDK1.2之后，双亲委派模式已经被引入到类加载体系中，自定义类加载器时不需要在自己写双亲委派的逻辑，因此不鼓励重写loadClass方法，而推荐重写findClass方法。</p><p>在Java中，任意一个类都需要由加载它的类加载器和这个类本身一同确定其在java虚拟机中的唯一性，即比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提之下才有意义，否则，即使这两个类来源于同一个Class类文件，只要加载它的类加载器不相同，那么这两个类必定不相等(这里的相等包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法和instanceof关键字的结果)。例子代码如下：</p><pre><code>/**      * 一、ClassLoader加载类的顺序      *  1.调用 findLoadedClass(String) 来检查是否已经加载类。      *  2.在父类加载器上调用 loadClass 方法。如果父类加载器为 null，则使用虚拟机的内置类加载器。      *  3.调用 findClass(String) 方法查找类。      * 二、实现自己的类加载器      *  1.获取类的class文件的字节数组      *  2.将字节数组转换为Class类的实例      * @author lei 2011-9-1      */      public class ClassLoaderTest {          public static void main(String[] args) throws InstantiationException, IllegalAccessException, ClassNotFoundException {              //新建一个类加载器              MyClassLoader cl = new MyClassLoader(&quot;myClassLoader&quot;);              //加载类，得到Class对象              Class&lt;?&gt; clazz = cl.loadClass(&quot;classloader.Animal&quot;);              //得到类的实例              Animal animal=(Animal) clazz.newInstance();              animal.say();          }      }      class Animal{          public void say(){              System.out.println(&quot;hello world!&quot;);          }      }      class MyClassLoader extends ClassLoader {          //类加载器的名称          private String name;          //类存放的路径          private String path = &quot;E:\\workspace\\Algorithm\\src&quot;;          MyClassLoader(String name) {              this.name = name;          }          MyClassLoader(ClassLoader parent, String name) {              super(parent);              this.name = name;          }          /**          * 重写findClass方法          */          @Override          public Class&lt;?&gt; findClass(String name) {              byte[] data = loadClassData(name);              return this.defineClass(name, data, 0, data.length);          }          public byte[] loadClassData(String name) {              try {                  name = name.replace(&quot;.&quot;, &quot;//&quot;);                  FileInputStream is = new FileInputStream(new File(path + name + &quot;.class&quot;));                  ByteArrayOutputStream baos = new ByteArrayOutputStream();                  int b = 0;                  while ((b = is.read()) != -1) {                      baos.write(b);                  }                  return baos.toByteArray();              } catch (Exception e) {                  e.printStackTrace();              }              return null;          }      }  复制代码</code></pre><p>类加载器双亲委派模型是从JDK1.2以后引入的，并且只是一种推荐的模型，不是强制要求的，因此有一些没有遵循双亲委派模型的特例：(了解)</p><p>(1).在JDK1.2之前，自定义类加载器都要覆盖loadClass方法去实现加载类的功能，JDK1.2引入双亲委派模型之后，loadClass方法用于委派父类加载器进行类加载，只有父类加载器无法完成类加载请求时才调用自己的findClass方法进行类加载，因此在JDK1.2之前的类加载的loadClass方法没有遵循双亲委派模型，因此在JDK1.2之后，自定义类加载器不推荐覆盖loadClass方法，而只需要覆盖findClass方法即可。</p><p>(2).双亲委派模式很好地解决了各个类加载器的基础类统一问题，越基础的类由越上层的类加载器进行加载，但是这个基础类统一有一个不足，当基础类想要调用回下层的用户代码时无法委派子类加载器进行类加载。为了解决这个问题JDK引入了ThreadContext线程上下文，通过线程上下文的setContextClassLoader方法可以设置线程上下文类加载器。</p><p>JavaEE只是一个规范，sun公司只给出了接口规范，具体的实现由各个厂商进行实现，因此JNDI，JDBC,JAXB等这些第三方的实现库就可以被JDK的类库所调用。线程上下文类加载器也没有遵循双亲委派模型。</p><p>(3).近年来的热码替换，模块热部署等应用要求不用重启java虚拟机就可以实现代码模块的即插即用，催生了OSGi技术，在OSGi中类加载器体系被发展为网状结构。OSGi也没有完全遵循双亲委派模型。</p><h4 id="动态加载Jar-amp-amp-ClassLoader-隔离问题"><a href="#动态加载Jar-amp-amp-ClassLoader-隔离问题" class="headerlink" title="动态加载Jar &amp;&amp; ClassLoader 隔离问题"></a><strong>动态加载Jar &amp;&amp; ClassLoader 隔离问题</strong></h4><p>动态加载Jar：</p><p>Java 中动态加载 Jar 比较简单，如下：</p><pre><code>URL[] urls = new URL[] {new URL(&quot;file:libs/jar1.jar&quot;)};  URLClassLoader loader = new URLClassLoader(urls, parentLoader);  复制代码</code></pre><p>表示加载 libs 下面的 jar1.jar，其中 parentLoader 就是上面1中的 parent，可以为当前的 ClassLoader。</p><p>ClassLoader 隔离问题：</p><p>大家觉得一个运行程序中有没有可能同时存在两个包名和类名完全一致的类？JVM 及 Dalvik 对类唯一的识别是 ClassLoader id + PackageName + ClassName，所以一个运行程序中是有可能存在两个包名和类名完全一致的类的。并且如果这两个”类”不是由一个 ClassLoader 加载，是无法将一个类的示例强转为另外一个类的，这就是 ClassLoader 隔离。 如 Android 中碰到如下异常[java] view plain copy</p><pre><code>android.support.v4.view.ViewPager can not be cast to android.support.v4.view.ViewPager  复制代码</code></pre><p>当碰到这种问题时可以通过 instance.getClass().getClassLoader(); 得到 ClassLoader，看 ClassLoader 是否一样。</p><p>加载不同 Jar 包中公共类：</p><p>现在 Host 工程包含了 common.jar, jar1.jar, jar2.jar，并且 jar1.jar 和 jar2.jar 都包含了 common.jar，我们通过 ClassLoader 将 jar1, jar2 动态加载进来，这样在 Host 中实际是存在三份 common.jar，如下图：</p><p><a href="https://farm4.staticflickr.com/3872/14301963930_2f0f0fe8aa_o.png" target="_blank" rel="noopener">https://farm4.staticflickr.com/3872/14301963930_2f0f0fe8aa_o.png</a></p><p>我们怎么保证 common.jar 只有一份而不会造成上面3中提到的 ClassLoader 隔离的问题呢，其实很简单，在生成 jar1 和 jar2 时把 common.jar 去掉，只保留 host 中一份，以 host ClassLoader 为 parentClassLoader 即可。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态代理的实现方式与区别</title>
      <link href="/2020/01/06/dong-tai-dai-li-de-shi-xian-fang-shi-yu-qu-bie/"/>
      <url>/2020/01/06/dong-tai-dai-li-de-shi-xian-fang-shi-yu-qu-bie/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java异常</title>
      <link href="/2020/01/05/java-yi-chang/"/>
      <url>/2020/01/05/java-yi-chang/</url>
      
        <content type="html"><![CDATA[<h2 id="Java异常介绍"><a href="#Java异常介绍" class="headerlink" title="Java异常介绍"></a>Java异常介绍</h2><p>异常时什么？就是指阻止当前方法或作用域继续执行的问题,当程序运行时出现异常时,系统就会自动生成一个Exception对象来通知程序进行相应的处理。Java异常的类型有很多种，下面我们就使用一张图来看一下Java异常的继承层次结构：</p><p><img src="/2020/01/05/java-yi-chang/java%E5%BC%82%E5%B8%B8%5C1.png" alt="img"></p><h3 id="Java异常中的Error"><a href="#Java异常中的Error" class="headerlink" title="Java异常中的Error"></a>Java异常中的Error</h3><p>Error一般表示编译时或者系统错误，例如：虚拟机相关的错误，系统崩溃（例如：我们开发中有时会遇到的OutOfMemoryError）等。这种错误无法恢复或不可捕获,将导致应用程序中断,通常应用程序无法处理这些错误,因此也不应该试图用catch来进行捕获。</p><h3 id="Java异常中的Exception"><a href="#Java异常中的Exception" class="headerlink" title="Java异常中的Exception"></a>Java异常中的Exception</h3><p>上面我们有介绍，Java异常的中的Exception分为受检查异常和运行时异常（不受检查异常）。下面我们展开介绍。</p><h4 id="Java中的受检查异常"><a href="#Java中的受检查异常" class="headerlink" title="Java中的受检查异常"></a>Java中的受检查异常</h4><p>相信大家在写IO操作的代码的时候，一定有过这样的记忆，对File或者Stream进行操作的时候一定需要使用try-catch包起来，否则编译会失败，这是因为这些异常类型是受检查的异常类型。编译器在编译时，对于受检异常必须进行try…catch或throws处理,否则无法通过编译。常见的受检查异常包括：IO操作、ClassNotFoundException、线程操作等。</p><h4 id="Java中的非受检查异常（运行时异常）"><a href="#Java中的非受检查异常（运行时异常）" class="headerlink" title="Java中的非受检查异常（运行时异常）"></a>Java中的非受检查异常（运行时异常）</h4><p>RuntimeException及其子类都统称为非受检查异常，例如：NullPointExecrption、NumberFormatException（字符串转换为数字）、ArrayIndexOutOfBoundsException（数组越界）、ClassCastException（类型转换错误）、ArithmeticException（算术错误）等。</p><h3 id="Java的异常处理"><a href="#Java的异常处理" class="headerlink" title="Java的异常处理"></a>Java的异常处理</h3><p>Java处理异常的一般格式是这样的：</p><pre><code>try{    ///可能会抛出异常的代码}catch(Type1 id1){    //处理Type1类型异常的代码}catch(Type2 id2){    //处理Type2类型异常的代码}复制代码</code></pre><p>try块中放置可能会发生异常的代码(但是我们不知道具体会发生哪种异常)。如果异常发生了，try块抛出系统自动生成的异常对象，然后异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序，然后进行catch语句执行(不会在向下查找)。如果我们的catch语句没有匹配到，那么JVM虚拟机还是会抛出异常的。</p><h4 id="Java中的throws关键字"><a href="#Java中的throws关键字" class="headerlink" title="Java中的throws关键字"></a>Java中的throws关键字</h4><p>如果在当前方法不知道该如何处理该异常时，则可以使用throws对异常进行抛出给调用者处理或者交给JVM。JVM对异常的处理方式是：打印异常的跟踪栈信息并终止程序运行。throws在使用时应处于方法签名之后使用，可以抛出多种异常并用英文字符逗号’,’隔开。下面是一个例子：</p><pre><code>public void f() throws ClassNotFoundException,IOException{}复制代码</code></pre><p>这样我们调用f()方法的时候必须要catch-ClassNotFoundException和IOException这两个异常或者catch-Exception基类。<br>注意：<br>throws的这种使用方式只是Java编译期要求我们这样做的，我们完全可以只在方法声明中throws相关异常，但是在方法里面却不抛出任何异常，这样也能通过编译，我们通过这种方式间接的绕过了Java编译期的检查。这种方式有一个好处：为异常先占一个位置，以后就可以抛出这种异常而不需要修改已有的代码。在定义抽象类和接口的时候这种设计很重要，这样派生类或者接口实现就可以抛出这些预先声明的异常。</p><h4 id="打印异常信息"><a href="#打印异常信息" class="headerlink" title="打印异常信息"></a>打印异常信息</h4><p>异常类的基类Exception中提供了一组方法用来获取异常的一些信息.所以如果我们获得了一个异常对象,那么我们就可以打印出一些有用的信息,最常用的就是void printStackTrace()这个方法,这个方法将返回一个由栈轨迹中的元素所构成的数组,其中每个元素都表示栈中的一帧.元素0是栈顶元素,并且是调用序列中的最后一个方法调用(这个异常被创建和抛出之处);他有几个不同的重载版本,可以将信息输出到不同的流中去.下面的代码显示了如何打印基本的异常信息:</p><pre><code>public void f() throws IOException{    System.out.println(&quot;Throws SimpleException from f()&quot;);     throw new IOException(&quot;Crash&quot;); } public static void main(String[] agrs) {    try {        new B().f();    } catch (IOException e) {        System.out.println(&quot;Caught  Exception&quot;);        System.out.println(&quot;getMessage(): &quot;+e.getMessage());        System.out.println(&quot;getLocalizedMessage(): &quot;+e.getLocalizedMessage());        System.out.println(&quot;toString(): &quot;+e.toString());        System.out.println(&quot;printStackTrace(): &quot;);        e.printStackTrace(System.out);    }}复制代码</code></pre><p>我们来看输出：</p><pre><code>Throws SimpleException from f()Caught  ExceptiongetMessage(): CrashgetLocalizedMessage(): CrashtoString(): java.io.IOException: CrashprintStackTrace(): java.io.IOException: Crash    at com.learn.example.B.f(RunMain.java:19)    at com.learn.example.RunMain.main(RunMain.java:26)复制代码</code></pre><h4 id="使用finally进行清理"><a href="#使用finally进行清理" class="headerlink" title="使用finally进行清理"></a>使用finally进行清理</h4><p>引入finally语句的原因是我们希望一些代码总是能得到执行,无论try块中是否抛出异常.这样异常处理的基本格式变成了下面这样:</p><pre><code>try{    //可能会抛出异常的代码}catch(Type1 id1){    //处理Type1类型异常的代码}catch(Type2 id2){    //处理Type2类型异常的代码}finally{    //总是会执行的代码}复制代码</code></pre><p>在Java中希望除内存以外的资源恢复到它们的初始状态的时候需要使用的finally语句。例如打开的文件或者网络连接，屏幕上的绘制的图像等。下面我们来看一下案例：</p><pre><code>public class FinallyException {    static int count = 0;    public static void main(String[] args) {        while (true){            try {                if (count++ == 0){                    throw new ThreeException();                }                System.out.println(&quot;no Exception&quot;);            }catch (ThreeException e){                System.out.println(&quot;ThreeException&quot;);            }finally {                System.out.println(&quot;in finally cause&quot;);                if(count == 2)                    break;            }        }    }}class ThreeException extends Exception{}复制代码</code></pre><p>我们来看输出：</p><pre><code>ThreeExceptionin finally causeno Exceptionin finally cause复制代码</code></pre><p>如果我们在try块或者catch块里面有return语句的话，那么finally语句还会执行吗？我们看下面的例子：</p><pre><code>public class MultipleReturns {    public static void f(int i){        System.out.println(&quot;start.......&quot;);        try {            System.out.println(&quot;1&quot;);            if(i == 1)                return;            System.out.println(&quot;2&quot;);            if (i == 2)                return;            System.out.println(&quot;3&quot;);            if(i == 3)                return;            System.out.println(&quot;else&quot;);            return;        }finally {            System.out.println(&quot;end&quot;);        }    }    public static void main(String[] args) {        for (int i = 1; i&lt;4; i++){            f(i);        }    }}复制代码</code></pre><p>我们来看运行结果：</p><pre><code>start.......1endstart.......12endstart.......123end复制代码</code></pre><p>我们看到即使我们在try或者catch块中使用了return语句，finally子句还是会执行。那么有什么情况finally子句不会执行呢？<br>有下面两种情况会导致Java异常的丢失</p><ul><li>finally中重写抛出异常（finally中重写抛出另一种异常会覆盖原来捕捉到的异常）</li><li>在finally子句中返回（即return）</li></ul><h3 id="Java异常栈"><a href="#Java异常栈" class="headerlink" title="Java异常栈"></a>Java异常栈</h3><p>前面稍微提到了点Java异常栈的相关内容，这一节我们通过一个简单的例子来更加直观的了解异常栈的相关内容。我们再看Exception异常的时候会发现，发生异常的方法会在最上层，main方法会在最下层，中间还有其他的调用层次。这其实是栈的结构，先进后出的。下面我们通过例子来看下：</p><pre><code>public class WhoCalled {    static void f() {        try {            throw new Exception();        } catch (Exception e) {            for (StackTraceElement ste : e.getStackTrace()){                System.out.println(ste.getMethodName());            }        }    }    static void g(){        f();    }    static void h(){        g();    }    public static void main(String[] args) {        f();        System.out.println(&quot;---------------------------&quot;);        g();        System.out.println(&quot;---------------------------&quot;);        h();        System.out.println(&quot;---------------------------&quot;);    }}复制代码</code></pre><p>我们来看输出结果：</p><pre><code>fmain---------------------------fgmain---------------------------fghmain---------------------------复制代码</code></pre><p>可以看到异常信息都是从内到外的，按我的理解查看异常的时候要从第一条异常信息看起，因为那是异常发生的源头。</p><h3 id="重新抛出异常及异常链"><a href="#重新抛出异常及异常链" class="headerlink" title="重新抛出异常及异常链"></a>重新抛出异常及异常链</h3><p>我们知道每遇到一个异常信息，我们都需要进行try…catch,一个还好，如果出现多个异常呢？分类处理肯定会比较麻烦，那就一个Exception解决所有的异常吧。这样确实是可以，但是这样处理势必会导致后面的维护难度增加。最好的办法就是将这些异常信息封装，然后捕获我们的封装类即可。<br>我们有两种方式处理异常，一是throws抛出交给上级处理，二是try…catch做具体处理。但是这个与上面有什么关联呢？try…catch的catch块我们可以不需要做任何处理，仅仅只用throw这个关键字将我们封装异常信息主动抛出来。然后在通过关键字throws继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。<br>通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性。<br>我们捕获异常以后一般会有两种操作</p><ul><li>捕获后抛出原来的异常，希望保留最新的异常抛出点－－fillStackTrace</li><li>捕获后抛出新的异常，希望抛出完整的异常链－－initCause</li></ul><h4 id="捕获异常后重新抛出异常"><a href="#捕获异常后重新抛出异常" class="headerlink" title="捕获异常后重新抛出异常"></a>捕获异常后重新抛出异常</h4><p>在函数中捕获了异常，在catch模块中不做进一步的处理，而是向上一级进行传递catch(Exception e){ throw e;}，我们通过例子来看一下：</p><pre><code>public class ReThrow {    public static void f()throws Exception{        throw new Exception(&quot;Exception: f()&quot;);    }    public static void g() throws Exception{        try{            f();        }catch(Exception e){            System.out.println(&quot;inside g()&quot;);            throw e;        }    }    public static void main(String[] args){        try{            g();        }        catch(Exception e){            System.out.println(&quot;inside main()&quot;);            e.printStackTrace(System.out);        }    }}复制代码</code></pre><p>我们来看输出：</p><pre><code>inside g()inside main()java.lang.Exception: Exception: f()        //异常的抛出点还是最初抛出异常的函数f()    at com.learn.example.ReThrow.f(RunMain.java:5)    at com.learn.example.ReThrow.g(RunMain.java:10)    at com.learn.example.RunMain.main(RunMain.java:21)复制代码</code></pre><h4 id="fillStackTrace——覆盖前边的异常抛出点-获取最新的异常抛出点"><a href="#fillStackTrace——覆盖前边的异常抛出点-获取最新的异常抛出点" class="headerlink" title="fillStackTrace——覆盖前边的异常抛出点(获取最新的异常抛出点)"></a>fillStackTrace——覆盖前边的异常抛出点(获取最新的异常抛出点)</h4><p>在此抛出异常的时候进行设置catch(Exception e){ (Exception)e.fillInStackTrace();}我们通过例子看一下：(还是刚才的例子)</p><pre><code>public void g() throws Exception{    try{        f();    }catch(Exception e){        System.out.println(&quot;inside g()&quot;);        throw (Exception)e.fillInStackTrace();    }}复制代码</code></pre><p>运行结果如下：</p><pre><code>inside g()inside main()java.lang.Exception: Exception: f()        //显示的就是最新的抛出点    at com.learn.example.ReThrow.g(RunMain.java:13)    at com.learn.example.RunMain.main(RunMain.java:21)复制代码</code></pre><h4 id="捕获异常后抛出新的异常（保留原来的异常信息，区别于捕获异常之后重新抛出）"><a href="#捕获异常后抛出新的异常（保留原来的异常信息，区别于捕获异常之后重新抛出）" class="headerlink" title="捕获异常后抛出新的异常（保留原来的异常信息，区别于捕获异常之后重新抛出）"></a>捕获异常后抛出新的异常（保留原来的异常信息，区别于捕获异常之后重新抛出）</h4><p>如果我们在抛出异常的时候需要保留原来的异常信息，那么有两种方式</p><ul><li>方式1:Exception e＝new Exception(); e.initCause(ex);</li><li>方式2:Exception e =new Exception(ex);</li></ul><pre><code>class ReThrow {    public void f(){        try{             g();          }catch(NullPointerException ex){             //方式1             Exception e=new Exception();             //将原始的异常信息保留下来             e.initCause(ex);             //方式2             //Exception e=new Exception(ex);             try {                throw e;            } catch (Exception e1) {                e1.printStackTrace();            }         }    }    public void g() throws NullPointerException{        System.out.println(&quot;inside g()&quot;);        throw new NullPointerException();    }}public class RunMain {    public static void main(String[] agrs) {        try{            new ReThrow().f();        }        catch(Exception e){            System.out.println(&quot;inside main()&quot;);            e.printStackTrace(System.out);        }    }}复制代码</code></pre><p>在这个例子里面，我们先捕获NullPointerException异常，然后在抛出Exception异常，这时候如果我们不使用initCause方法将原始异常（NullPointerException）保存下来的话，就会丢失NullPointerException。只会显示Eception异常。下面我们来看结果：</p><pre><code>//没有调用initCause方法的输出inside g()java.lang.Exception    at com.learn.example.ReThrow.f(RunMain.java:9)    at com.learn.example.RunMain.main(RunMain.java:31)//调用initCasue方法保存原始异常信息的输出inside g()java.lang.Exception    at com.learn.example.ReThrow.f(RunMain.java:9)    at com.learn.example.RunMain.main(RunMain.java:31)Caused by: java.lang.NullPointerException    at com.learn.example.ReThrow.g(RunMain.java:24)    at com.learn.example.ReThrow.f(RunMain.java:6)    ... 1 more复制代码</code></pre><p>我们看到我们使用initCause方法保存后，原始的异常信息会以Caused by的形式输出。</p><h3 id="Java异常的限制"><a href="#Java异常的限制" class="headerlink" title="Java异常的限制"></a>Java异常的限制</h3><p>当Java异常遇到继承或者接口的时候是存在限制的，下面我们来看看有哪些限制。</p><ul><li>规则一：子类在重写父类抛出异常的方法时，要么不抛出异常，要么抛出与父类方法相同的异常或该异常的子类。如果被重写的父类方法只抛出受检异常，则子类重写的方法可以抛出非受检异常。例如，父类方法抛出了一个受检异常IOException，重写该方法时不能抛出Exception，对于受检异常而言，只能抛出IOException及其子类异常，也可以抛出非受检异常。我们通过例子来看下：</li></ul><pre><code>class A {      public void fun() throws Exception {}  }  class B extends A {      public void fun() throws IOException, RuntimeException {}  }复制代码</code></pre><p>父类抛出的异常包含所有异常，上面的写法正确。</p><pre><code>class A {      public void fun() throws RuntimeException {}  }  class B extends A {      public void fun() throws IOException, RuntimeException {}  }复制代码</code></pre><p>子类IOException超出了父类的异常范畴，上面的写法错误。</p><pre><code>class A {      public void fun() throws IOException {}  }  class B extends A {      public void fun() throws IOException, RuntimeException, ArithmeticException{}}复制代码</code></pre><p>RuntimeException不属于IO的范畴，并且超出了父类的异常范畴。但是RuntimeException和ArithmeticException属于运行时异常，子类重写的方法可以抛出任何运行时异常。所以上面的写法正确。</p><ul><li>规则儿：子类在重写父类抛出异常的方法时，如果实现了有相同方法签名的接口且接口中的该方法也有异常声明，则子类重写的方法要么不抛出异常，要么抛出父类中被重写方法声明异常与接口中被实现方法声明异常的交集。</li></ul><pre><code>class Test {    public Test() throws IOException {}    void test() throws IOException {}}interface I1{    void test() throw Exception;}class SubTest extends Test implements I1 {    public SubTest() throws Exception,NullPointerException, NoSuchMethodException {}    void test() throws IOException {}}复制代码</code></pre><p>在SubTest类中，test方法要么不抛出异常，要么抛出IOException或其子类（例如，InterruptedIOException）。</p><h3 id="Java异常与构造器"><a href="#Java异常与构造器" class="headerlink" title="Java异常与构造器"></a>Java异常与构造器</h3><p>如果一个构造器中就发生异常了，那我们如何处理才能正确的清呢？也许你会说使用finally啊，它不是一定会执行的吗？这可不一定，如果构造器在其执行过程中遇到了异常，这时候对象的某些部分还没有正确的初始化，而这时候却会在finally中对其进行清理，显然这样会出问题的。<br>原则：<br>对于在构造器阶段可能会抛出异常，并且要求清理的类，最安全的方式是使用嵌套的try子句。</p><pre><code>try {    InputFile in=new InpputFile(&quot;Cleanup.java&quot;);    try {        String string;        int i=1;        while ((string=in.getLine())!=null) {}    }catch (Exception e) {        System.out.println(&quot;Cause Exception in main&quot;);        e.printStackTrace(System.out);    }finally {        in.dispose();    }}catch (Exception e) {    System.out.println(&quot;InputFile construction failed&quot;);}复制代码</code></pre><p>我们来仔细看一下这里面的逻辑，对InputFile的构造在第一个try块中是有效的，如果构造器失败，抛出异常，那么会被最外层的catch捕获到，这时候InputFile对象的dispose方法是不需要执行的。如果构造成功，那么进入第二层try块，这时候finally块肯定是需要被调用的（对象需要dispose）。</p><h2 id="java项目中的异常处理方式"><a href="#java项目中的异常处理方式" class="headerlink" title="java项目中的异常处理方式"></a>java项目中的异常处理方式</h2><h3 id="统一抛出异常"><a href="#统一抛出异常" class="headerlink" title="统一抛出异常"></a>统一抛出异常</h3><ul><li>首先定义一个自定义异常类继承RuntimeException</li></ul><pre><code>@Data@AllArgsConstructorpublic class CustomException extends RuntimeException {    ResultCode resultCode;}</code></pre><ul><li>然后定义一个异常抓取类负责抛出异常</li></ul><pre><code>public class ExceptionCast {    public static void cast(ResultCode resultCode){        throw new CustomException(resultCode);    }}</code></pre><ul><li>在业务代码中抛出异常</li></ul><pre><code>if (!optional.isPresent()) {    ExceptionCast.cast(CmsCode.CMS_SITE_NOEXISTS);}</code></pre><h3 id="统一抓获异常再具体处理"><a href="#统一抓获异常再具体处理" class="headerlink" title="统一抓获异常再具体处理"></a>统一抓获异常再具体处理</h3><ul><li>异常分两类处理,一种是自己定义的异常,一种是系统异常.对创建一份Map保存一些已经事先知道或者遇到过的异常,当捕获到该类异常时获取预先设置的响应状态,遇到没有见过的异常则统一响应</li></ul><pre><code>@RestControllerAdvicepublic class ExceptionCatch {    Logger logger = LoggerFactory.getLogger(ExceptionCatch.class);    //使用EXCEPTIONS存放异常类型和错误代码的映射,ImmutableMap的特点是一旦创建就不可改变,并且线程安全.    private static ImmutableMap&lt;Class&lt;? extends Throwable&gt;, ResultCode&gt; EXCEPTIONS;    //使用builder来构建一个异常类型和错误代码的异常    protected static ImmutableMap.Builder&lt;Class&lt;? extends Throwable&gt;, ResultCode&gt; builder = ImmutableMap.builder();    static {        builder.put(HttpMediaTypeNotSupportedException.class, CommonCode.INVAILDPARAM);    }    //捕获CustomException异常    @ExceptionHandler(CustomException.class)    public ResponseResult customException(CustomException customException) {        logger.error(&quot;catch exception : {}\r\nexception:&quot;, customException.getMessage(), customException);        ResultCode resultCode = customException.getResultCode();        return new ResponseResult(resultCode);    }    //捕获不可预知异常    @ExceptionHandler(Exception.class)    public ResponseResult exception(Exception exception) {        logger.error(&quot;catch exception : {}\r\nexception:&quot;, exception.getMessage(), exception);        if (EXCEPTIONS == null) {            EXCEPTIONS = builder.build();        }        ResultCode resultCode = EXCEPTIONS.get(exception.getClass());        ResponseResult responseResult;        if (resultCode != null) {            responseResult = new ResponseResult(resultCode);        } else {            responseResult = new ResponseResult(CommonCode.SERVER_ERROR);        }        return responseResult;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javaWeb三大核心组件之servlet</title>
      <link href="/2020/01/04/javaweb-san-da-he-xin-zu-jian-zhi-servlet/"/>
      <url>/2020/01/04/javaweb-san-da-he-xin-zu-jian-zhi-servlet/</url>
      
        <content type="html"><![CDATA[<h1 id="javaWeb三大核心组件之Servlet"><a href="#javaWeb三大核心组件之Servlet" class="headerlink" title="javaWeb三大核心组件之Servlet"></a>javaWeb三大核心组件之Servlet</h1><h3 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a>什么是Servlet</h3><p>Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</p><p>使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。</p><p>Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势：</p><p>性能明显更好。</p><p>Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。</p><p>Servlet 是独立于平台的，因为它们是用 Java 编写的。</p><p>服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。</p><p>Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。</p><h3 id="Tomcat与Servlet的关系"><a href="#Tomcat与Servlet的关系" class="headerlink" title="Tomcat与Servlet的关系"></a>Tomcat与Servlet的关系</h3><p>Tomcat 是Web应用服务器,是一个Servlet/JSP容器. Tomcat 作为Servlet容器,负责处理客户请求,把请求传送给Servlet,并将Servlet的响应传送回给客户.而Servlet是一种运行在支持Java语言的服务器上的组件.。</p><p>Servlet最常见的用途是扩展Java Web服务器功能,提供非常安全的,可移植的,易于使用的CGI替代品。从http协议中的请求和响应可以得知，浏览器发出的请求是一个请求文本，而浏览器接收到的也应该是一个响应文本。</p><p><img src="/2020/01/04/javaweb-san-da-he-xin-zu-jian-zhi-servlet/javaWeb%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B9%8Bservlet%5C1" alt="image"></p><ol><li>Tomcat将http请求文本接收并解析，然后封装成HttpServletRequest类型的request对象，所有的HTTP头数据读可以通过request对象调用对应的方法查询到。</li><li>Tomcat同时会要响应的信息封装为HttpServletResponse类型的response对象，通过设置response属性就可以控制要输出到浏览器的内容，然后将response交给tomcat，tomcat就会将其变成响应文本的格式发送给浏览器。</li></ol><p>Java Servlet API 是Servlet容器(tomcat)和servlet之间的接口，它定义了serlvet的各种方法，还定义了Servlet容器传送给Servlet的对象类，其中最重要的就是ServletRequest和ServletResponse。所以说我们在编写servlet时，需要实现Servlet接口，按照其规范进行操作。</p><h3 id="Servlet执行过程"><a href="#Servlet执行过程" class="headerlink" title="Servlet执行过程"></a>Servlet执行过程</h3><p> 在浏览器的地址栏输入：<a href="http://ip" target="_blank" rel="noopener">http://ip</a>:port/appNames/servlet</p><p>  1）通过浏览器和ip：port和这个服务器建立连接。<br>  2） 浏览器会生成一个请求数据包（路径appNames/servlet）向服务器发送请求。<br>  3） 服务器收到请求数据包，分析请求资源路径做精准定位，通过请求的appName查找webapps文件下面的appName做匹配，匹配上了需要获取web.xml中的servlet(mapping)。 <br>  4） 服务器创建两个对象：<br>    第一个对象：请求对象，该对象实现了HttpServletRequest接口，服务器会将请求数据包中的数据解析出来,存储在该对象里。这样做的好处是没有必要理解http协议，只需要读取request。<br>    第二个对象：响应对象，实现了HttpServletResponse接口，作用是servlet处理完成后的结果可以存放到该对象上，然后服务器依据该对象的数据生成响应数据包。<br>  5） servlet在执行servlet()方法时，可以通过request获取请求数据，也可以将处理结果存放到response上。然后服务器与响应对象直接形成一个默契，生成一个响应数据包给浏览器。<br>  6）浏览器解析服务器返回的响应数据包，生成响应的结果。</p><p>  </p><p><img src="/2020/01/04/javaweb-san-da-he-xin-zu-jian-zhi-servlet/javaWeb%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B9%8Bservlet%5C2.png" alt="image"></p><p>Servlet访问的过程：<br>Http请求—-&gt;web.xml——–&gt;  url -pattern—–&gt;servlet-name—–&gt;servlet-class—–&gt;   QuickStratServlet(对应的Class文件)</p><h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><p>SpringMVC是基于servlet，控制器基于方法级别的拦截，处理器设计为单实例，所以应该了解一下Servlet的生命周期。</p><p>Servlet 加载—&gt;实例化—&gt;服务—&gt;销毁。</p><p><strong>init</strong>（）：</p><p>在Servlet的生命周期中，仅执行一次init()方法。它是在服务器装入Servlet时执行的，负责初始化Servlet对象。可以配置服务器，以在启动服务器或客户机首次访问Servlet时装入Servlet。无论有多少客户机访问Servlet，都不会重复执行init（）。</p><p><strong>service</strong>（）：</p><p>它是Servlet的核心，负责响应客户的请求。每当一个客户请求一个HttpServlet对象，该对象的Service()方法就要调用，而且传递给这个方法一个“请求”（ServletRequest）对象和一个“响应”（ServletResponse）对象作为参数。在HttpServlet中已存在Service()方法。默认的服务功能是调用与HTTP请求的方法相应的do功能。</p><p><strong>destroy</strong>（）：</p><p>仅执行一次，在服务器端停止且卸载Servlet时执行该方法。当Servlet对象退出生命周期时，负责释放占用的资源。一个Servlet在运行service()方法时可能会产生其他的线程，因此需要确认在调用destroy()方法时，这些线程已经终止或完成。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC原理</title>
      <link href="/2020/01/04/springmvc-yuan-li/"/>
      <url>/2020/01/04/springmvc-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="http://lib.csdn.net/base/javaee" target="_blank" rel="noopener">spring</a> MVC主要由DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图组成。他的两个核心是两个核心：</p><p><strong>处理器映射：</strong> 选择使用哪个控制器来处理请求。<br><strong>视图解析器：</strong> 选择结果应该如何渲染。</p><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><p>下图是在Spring官网开发手册上找到的，它清晰的诠释了Spring MVC的运行原理</p><p><img src="/2020/01/04/springmvc-yuan-li/SpringMVC%E5%8E%9F%E7%90%86%5C16b5eb3870589ac4.png" alt="16b5eb3870589ac4"></p><p>①客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。</p><p>② DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）。</p><p>③在这个地方Spring会通过HandlerAdapter对该处理器进行封装。</p><p>④ HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用。</p><p>⑤ Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView顾名思义，包含了数据模型以及相应的视图的信息。</p><p>⑥ ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。⑦ 当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。</p><p>⑧ 客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。</p><p><img src="/2020/01/04/springmvc-yuan-li/SpringMVC%E5%8E%9F%E7%90%86%5C16b5eb3870589ac4.png" alt="16b5eb3870589ac4"></p><h2 id="接口的解释"><a href="#接口的解释" class="headerlink" title="接口的解释"></a>接口的解释</h2><table><thead><tr><th>接口名称</th><th>功能</th></tr></thead><tbody><tr><td>DispatcherServlet</td><td>Spring提供的前端控制器，客户端的所有请求都由DispatcherServlet负责分发，当然在DispatcherServlet分发之前，还需要一个匹配请求的过程，这个由HandlerMapping来完成。</td></tr><tr><td>HandlerMapping</td><td>完成客户端请求到Controller映射的工作</td></tr><tr><td>Controller</td><td>用于处理用户请求，返回处理结果</td></tr><tr><td>ViewResolver</td><td>Web应用中查找View对象，从而将相应结果渲染给客户端</td></tr></tbody></table><h2 id="DispatcherServlet："><a href="#DispatcherServlet：" class="headerlink" title="DispatcherServlet："></a>DispatcherServlet：</h2><p>是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。</p><p>其主要工作有以下三项：</p><ol><li>截获符合特定格式的URL请求。</li><li>初始化DispatcherServlet上下文对应WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。</li><li>初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。</li></ol><h2 id="一个比较好理解的Spring-mvc原理图"><a href="#一个比较好理解的Spring-mvc原理图" class="headerlink" title="一个比较好理解的Spring mvc原理图"></a>一个比较好理解的Spring mvc原理图</h2><p><img src="/2020/01/04/springmvc-yuan-li/SpringMVC%E5%8E%9F%E7%90%86%5Cb856096cf065baaaabe5884deb4ecfa3.png" alt="b856096cf065baaaabe5884deb4ecfa3"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>回头再看spring</title>
      <link href="/2020/01/04/hui-tou-zai-kan-spring/"/>
      <url>/2020/01/04/hui-tou-zai-kan-spring/</url>
      
        <content type="html"><![CDATA[<h2 id="回头再看Spring"><a href="#回头再看Spring" class="headerlink" title="回头再看Spring"></a>回头再看Spring</h2><h3 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h3><p>Spring是个包含一系列功能的合集，如快速构建微服务的Spring Boot，管理一系列微服务的Spring Cloud，支持认证与鉴权的Spring Security，基于MVC的Web框架Spring MVC。但IOC与AOP依然是核心。</p><h3 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h3><p><strong>IOC的底层原理：文档解析xml文件，反射动态创建对象，然后保存name和Object，然后对每个对象属性进行属性注入</strong></p><h5 id="加载Bean的主要逻辑"><a href="#加载Bean的主要逻辑" class="headerlink" title="加载Bean的主要逻辑"></a>加载Bean的主要逻辑</h5><p>​    1.获取配置文件资源</p><p>​    2.对获取的xml资源进行一定的处理检验</p><p>​    3.处理包装资源</p><p>​    4.解析处理包装过后的资源</p><p>​    5.加载提取bean并注册(添加到beanDefinitionMap中</p><h5 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h5><ul><li>Bean的建立，由BeanFactory读取Bean定义文件，并创建Bean实例；</li><li>执行Bean的属性注入,Setter注入；</li><li>如果Bean类实现了org.springframework.beans.factory.BeanNameAware接口,则执行其setBeanName方法；</li><li>如果Bean类实现了org.springframework.beans.factory.BeanFactoryAware接口,则执行其setBeanFactory方法；</li><li>如果容器中有实现org.springframework.beans.factory.BeanPostProcessors接口的实例，则任何Bean在初始化之前都会执行这个实例的processBeforeInitialization()方法；</li><li>如果Bean类实现了org.springframework.beans.factory.InitializingBean接口，则执行其afterPropertiesSet()方法；</li><li>调用Bean的初始化方法”init-method” (！！注意，init-method方法没有参数)；</li><li>如果容器中有实现org.springframework.beans.factory.BeanPostProcessors接口的实例，则任何Bean在初始化之后都会执行这个实例的processAfterInitialization()方法；</li><li>使用Bean做一些业务逻辑….</li><li>使用完，容器关闭，如果Bean类实现了org.springframework.beans.factory.DisposableBean接口，则执行它的destroy()方法；</li><li>在容器关闭时，可以在Bean定义文件中使用“destory-method”定义的方法，销毁Bean (！！注意，destory-method方法没有参数)；</li></ul><h5 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h5><ul><li>Singleton: 这是默认的作用域，这种范围确保不管接受多少个请求，每个容器中只有一个bean的实例，单例模式有BeanFactory自身维护；</li><li>Prototype: 原形范围与单例范围相反，为每一个bean请求提供一个实例；</li></ul><ul><li>Request: 在请求bean范围内会为每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收；</li><li>Session: 与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效；</li><li>global-session: global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。</li></ul><h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h3><p>IOC(控制反转):本质就是自己的信息(全类名等)配置在文件中或者加上注解,让容器可以通过反射的方式来创建对象,从而接管对象,代替了自己通过new创建对象.其实就是讲对象的管理创建交给了容器来做.</p><p>依赖注入:在运行过程中,会在需要这个对象的位置坐上一个标记,容器会负责创建对象实例并注入其中;</p><h4 id="Spring-IOC容器的初始化过程"><a href="#Spring-IOC容器的初始化过程" class="headerlink" title="Spring IOC容器的初始化过程"></a>Spring IOC容器的初始化过程</h4><p>IoC容器的初始化就是含有BeanDefinition信息的Resource的定位、载入、解析、注册四个过程，最终我们配置的bean，以beanDefinition的数据结构存在于IoC容器即内存中。</p><h5 id="Resource定位过程"><a href="#Resource定位过程" class="headerlink" title="Resource定位过程"></a>Resource定位过程</h5><p>这个Resource定位指的是BeanDefinition的资源定位，它由ResourceLoader通过统一的Resource接口来完成，这个Resource对各种形式的BeanDefinition的使用提供了统一接口。</p><h5 id="BeanDefinition的载入"><a href="#BeanDefinition的载入" class="headerlink" title="BeanDefinition的载入"></a>BeanDefinition的载入</h5><p>该载入过程把用户定义好的Bean表示成IoC容器内部的数据结构，而这个容器内部的数据结构就BeanDefinition.</p><h5 id="向IoC容器注册这些BeanDefinition"><a href="#向IoC容器注册这些BeanDefinition" class="headerlink" title="向IoC容器注册这些BeanDefinition"></a>向IoC容器注册这些BeanDefinition</h5><p>这个过程是通过调用BeanDefinitionRegistry接口的实现来完成的，这个注册过程把载入过程中解析得到的BeanDefinition向IoC容器进行注册,在IoC容器内部将BeanDefinition注入到一个HashMap中去，Ioc容器是通过这个HashMap来持有这些BeanDefinition数据的。</p><p>容器的初始化是通过AbstractApplicationContext的refresh()实现的。</p><pre><code></code></pre><p>整个过程如下图:</p><p><img src="/2020/01/04/hui-tou-zai-kan-spring/%E5%9B%9E%E5%A4%B4%E5%86%8D%E7%9C%8Bspring%5C1.png" alt="img"></p><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p>面向切面的编程，是一种编程技术，<strong>是OOP（面向对象编程）的补充和完善</strong>。OOP的执行是一种从上往下的流程，并没有从左到右的关系。因此在OOP编程中，会有大量的重复代码。而<strong>AOP则是将这些与业务无关的重复代码抽取出来，然后再嵌入到业务代码当中</strong>。常见的应用有：权限管理、日志、事务管理等。</p><p>AOP有三种植入切面的方法：其一是编译期织入，这要求使用特殊的Java编译器，AspectJ是其中的代表者；其二是类装载期织入，而这要求使用特殊的类装载器，AspectJ和AspectWerkz是其中的代表者；其三为动态代理织入，在运行期为目标类添加增强生成子类的方式，<strong>Spring AOP采用动态代理织入切面</strong>。</p><p>AspectJ是静态代理的增强，所谓的静态代理就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强。</p><p>它会在<strong>编译阶段</strong>将Aspect织入Java字节码中， 运行的时候就是经过增强之后的AOP对象。</p><p>AspectJ在编译时就增强了目标对象，Spring AOP的动态代理则是在每次运行时动态的增强，生成AOP代理对象，区别在于生成AOP代理对象的时机不同，相对来说<strong>AspectJ的静态代理方式具有更好的性能</strong>，但是AspectJ<strong>需要特定的编译器</strong>进行处理，而Spring AOP则无需特定的编译器处理。</p><p>Spring AOP中的动态代理主要有两种方式，<strong>JDK动态代理</strong>和<strong>CGLIB动态代理</strong>。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。<strong>JDK动态代理的核心是InvocationHandler接口和Proxy类</strong>。</p><p>如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态地生成某个类的子类，注意，<strong>CGLIB是通过继承的方式做的动态代理</strong>，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的</p><h4 id="jDK代理"><a href="#jDK代理" class="headerlink" title="jDK代理"></a>jDK代理</h4><p> JDK的动态代理主要涉及到java.lang.reflect包中的两个类：Proxy和InvocationHandler。其中 InvocationHandler是一个接口就是拦截器的接口。，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编织在一起。</p><h5 id="InvocationHandler的作用"><a href="#InvocationHandler的作用" class="headerlink" title="InvocationHandler的作用"></a>InvocationHandler的作用</h5><p>在动态代理中InvocationHandler是核心，每个代理实例都具有一个关联的调用处理程序(InvocationHandler)。对代理实例调用方法时，将对方法调用进行编码并将其指派到它的调用处理程序(InvocationHandler)的 invoke 方法。所以对代理方法的调用都是通InvocationHadler的invoke来实现中，而invoke方法根据传入的代理对象，方法和参数来决定调用代理的哪个方法</p><h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><p>使用代理模式必须要让代理类和目标类实现相同的接口，客户端通过代理类来调用目标方法，代理类会将所有的方法调用分派到目标对象上反射执行，还可以在分派过程中添加”前置通知”和后置处理（如在调用目标方法前校验权限，在调用完目标方法后打印日志等）等功能。</p><p>具体有如下四步骤：</p><p>1.通过实现 InvocationHandler 接口创建自己的调用处理器；</p><p>2.通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</p><p>3.通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</p><p>4.通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</p><p><img src="/2020/01/04/hui-tou-zai-kan-spring/%E5%9B%9E%E5%A4%B4%E5%86%8D%E7%9C%8Bspring%5Cclipboard.png" alt="clipboard"></p><h4 id="利用cglib代理实现AOP"><a href="#利用cglib代理实现AOP" class="headerlink" title="利用cglib代理实现AOP"></a>利用cglib代理实现AOP</h4><p>CGlib是一个强大的,高性能,高质量的Code生成类库。cglib封装了asm，可以在运行期动态生成新的class，它可以在运行期扩展Java类与实现Java接口。 CGLIB是<strong>针对类实现代理</strong>的，主要对指定的类生成一个子类，并覆盖其中的方法， 因为是继承，所以不能使用final来修饰类或方法。和jdk代理实现不同的是，cglib不要求类实现接口。</p><p>JDK动态代理和CGLIB字节码生成的区别？</p><p>CGLib所创建的动态代理对象的性能比JDK的高大概10倍，但CGLib在创建代理对象的时间比JDK大概多8倍，所以对于singleton的代理对象或者具有实例池的代理，因为无需重复的创建代理对象，所以比较适合CGLib动态代理技术，反之选择JDK代理</p><ul><li><p>JDK动态代理只能对实现了接口的类生成代理，而不能针对类</p></li><li><p>CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法</p><p>因为是继承，所以该类或方法最好不要声明成final </p></li></ul><p>1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP</p><p>2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP</p><p>3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>理解KMP回溯</title>
      <link href="/2020/01/03/li-jie-kmp-hui-su/"/>
      <url>/2020/01/03/li-jie-kmp-hui-su/</url>
      
        <content type="html"><![CDATA[<h4 id="理解KMP回溯"><a href="#理解KMP回溯" class="headerlink" title="理解KMP回溯"></a>理解KMP回溯</h4><p>相信大家都看过KMP算法，但是对于它的回溯确是难以理解。我们先来看一下KMP中的next数组生成代码：</p><pre><code>    //用于生成next数组    private static int[] get_next(String target){        int[] next = new int[target.length()];        next[0] = -1;        int i = 0, j = -1;        while(i &lt; target.length() - 1){            if (j == -1 || target.charAt(i) == target.charAt(j)) {                ++i;                ++j;                next[i] = j;            } else {                j = next[j];            }        }        return next;    }</code></pre><ul><li>其中数组的next中的值计算方式是：</li></ul><p>next[j] = Max{k | 1&lt;k&lt;j,且‘p1p2…pk’=‘p(j-k)…p(j - 1)’}</p><ul><li><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5></li></ul><p><em>简单来说next[j]表示的就是两个相等的字符串的长度，这两个字符串分别是从头开始记的长度为next[j]的和以next[j]的前一个字符结尾的长度为next[j]。</em></p><ul><li><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5></li></ul><p>例如：字符串”ababaaaba” next = [-1,0,0,1,2,3,1,1,2]<br>其中的回溯环节就是从next[5] = 3 到 next[6] = 1;</p><p>其中next[5]时：是”ababa”中前缀”aba”与后缀”aba”的长度，当i = 6时，”ababaa”中”a”不等于”b”,所以回溯到j = next[j],其中j为现在next[5]的值。</p><ul><li><h5 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h5></li></ul><p><strong>我开始也是很不明白为什么就可以直接回到j = next[next[5]] = 0处开始向后比较，后来仔细研究发现原因是，通过前面的比较它已经排除了所有的前缀字符串等于后缀字符串的长度大于回溯到当前j的可能 。</strong><br>就拿上面的“ababa”到“ababaa”举例：<br>其实我们想不通的无非就是它是怎么排除“aba”!=”baa”转而直接去判断前缀“ab”是否等于后缀“aa”,后来我仔细分析才发现因为如果前面的“aba” = “baa”要成立，必须有“前缀ab”等于后缀“ba”,而得到next[5]=3的时候已经隐式的得到的第一个“ba”等于第二个“ba”(当时是“aba” = “aba”)<br>从而有“aba”中三个值都应该相等，与前面矛盾。可能你早就看不懂我在说什么了，来一点数学表达式比较实际：</p><ul><li><h5 id="数学证明"><a href="#数学证明" class="headerlink" title="数学证明"></a>数学证明</h5></li></ul><p>②开始有p1p2….pj = pi - j ….pi-1，可以得出pj = pj-1  j = 1,2,…<br>假设 next[j] = k 就有 p1p2…pk = pj-k …pj-1    k = 1,2…<br>若加入pi != pj + 1,则需要回溯到判断pk 是否等于pj;<br>首先证明：pi-j+1…pi ！= p1p2…pj,反证：假设：pi-j+1…pi = p1p2…p，又p1p2….pj = pi - j ….pi-1<br>所以有pi - j ….pi-1 =pi-j+1…pi ,得到pi-j=pi-j+1=…=pi;与前面矛盾，所以有pi-j+1…pi ！= p1p2…pj<br>同理可以得出pi-j+2…pi ！= p1p2…pj-1  。。。。。pi-j+k…pi ！= p1p2…pj-k+1  。。。。。<br>所以可以直接回溯到j = next[j]继续向后判断</p><p>KMP完整代码</p><pre><code>    private static int[] get_next(String target){        int[] next = new int[target.length()];        next[0] = -1;        int i = 0, j = -1;        while(i &lt; target.length() - 1){            if (j == -1 || target.charAt(i) == target.charAt(j)) {                ++i;                ++j;                next[i] = j;            } else {                j = next[j];            }        }        return next;    }    int kmp(String s, String pattern) {        int i = 0,j = 0;        int slen = s.length(), plen = pattern.length();        int[] next = get_next(pattern);        while (i &lt; slen &amp;&amp; j &lt; plen) {            if (s.charAt(i) == pattern.charAt(j)) {                i++;                j++;            } else {                if (next[j] == -1) {                    i++;                    j = 0;                } else {                    j = next[j];                }            }            if (j == plen) {                return i - j;            }        }        return -1;    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用VMware安装linux虚拟机</title>
      <link href="/2019/12/29/shi-yong-vmware-an-zhuang-linux-xu-ni-ji/"/>
      <url>/2019/12/29/shi-yong-vmware-an-zhuang-linux-xu-ni-ji/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=552192975&auto=0&height=66"></iframe></div><h1 id="使用VMware安装linux虚拟机"><a href="#使用VMware安装linux虚拟机" class="headerlink" title="使用VMware安装linux虚拟机"></a>使用VMware安装linux虚拟机</h1><h3 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h3><p><em>Linux是一种自由和开放源码的操作系统，存在着许多不同的Linux发行版本，但它们都使用了Linux内核。现在的服务器基本都是使用linux,其中CentOS使用广泛,还有ubuntu也是linux中的佼佼者.业内也说,凡是<strong>java开发,不懂linux均是扯淡.</strong>本文主要为后面搭建基于Hadoop集群的大数据大数据平台打下基础。</em></p><h4 id="linux具有如下优点"><a href="#linux具有如下优点" class="headerlink" title="linux具有如下优点"></a>linux具有如下优点</h4><ul><li>开源</li><li>多用户，多任务，丰富的网络功能，可靠的系统安全，良好的可移植性，具有标准兼容性</li><li>良好的用户界面，出色的速度性能</li><li>服务器不使用图形化界面(图形界面占用资源)</li><li>机房部署方便，无需配置操作界面</li></ul><p><strong>下载地址</strong><a href="http://www.centos.org/" target="_blank" rel="noopener">:http://www.centos.org/</a></p><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><ul><li>Windows10</li><li>VMware Workstation12</li><li>CentOS7</li></ul><h4 id="VMware-Workstation12安装"><a href="#VMware-Workstation12安装" class="headerlink" title="VMware Workstation12安装"></a>VMware Workstation12安装</h4><p>①双击VMware-workstation-full-版本号.exe</p><p>②点击next</p><p>③选择Typical(你要是想自己配置也可以选custom 不推荐)</p><p>④选择安装目录</p><p>⑤想检查升级就勾上(check for product updates on startup),否则直接下一步</p><p>⑥选择创建快捷方式的位置,然后下一步</p><p>⑦点击continue完成</p><p>⑧Finish完成</p><p><strong>注意:如果你不熟悉就按部就班来,不要有什么骚操作,我记得我开始安装的时候禁用了哪两个网卡,后来哪两个网卡找不到了,我就把这个卸载了重新装,还是不行,这个问题的解决还是因为我一个月后重装了电脑</strong></p><h4 id="CentOS7安装"><a href="#CentOS7安装" class="headerlink" title="CentOS7安装"></a>CentOS7安装</h4><p>①安装VMware Workstation</p><p>②打开VM,点击创建新的虚拟机</p><p>③选择 典型（推荐）→ 下一步 </p><p>④选择稍后安装操作系统再点击下一步</p><p>⑤选择操作系统和版本(linux 64)</p><p>⑥输入虚拟机名称和安装路径</p><p>⑦设置磁盘大小并选中将虚拟磁盘拆成多个文件</p><p>⑧自定义硬件</p><p>⑨选择CentOS安装镜像文件</p><p><img src="/2019/12/29/shi-yong-vmware-an-zhuang-linux-xu-ni-ji/%E4%BD%BF%E7%94%A8VMware%E5%AE%89%E8%A3%85linux%E8%99%9A%E6%8B%9F%E6%9C%BA%5C1577631145598.png" alt="1577631145598"></p><p>⑩开机启动后选择Install CentOS 7并enter</p><ul><li>弹出如下图形化的安装界面：</li></ul><p><img src="/2019/12/29/shi-yong-vmware-an-zhuang-linux-xu-ni-ji/%E4%BD%BF%E7%94%A8VMware%E5%AE%89%E8%A3%85linux%E8%99%9A%E6%8B%9F%E6%9C%BA%5Cformat.png" alt="img"></p><ul><li>日期和时间：</li></ul><p><img src="/2019/12/29/shi-yong-vmware-an-zhuang-linux-xu-ni-ji/%E4%BD%BF%E7%94%A8VMware%E5%AE%89%E8%A3%85linux%E8%99%9A%E6%8B%9F%E6%9C%BA%5Cformat1.png" alt="img"><img src="/2019/12/29/shi-yong-vmware-an-zhuang-linux-xu-ni-ji/%E4%BD%BF%E7%94%A8VMware%E5%AE%89%E8%A3%85linux%E8%99%9A%E6%8B%9F%E6%9C%BA%5Cformat2.png" alt="img"></p><ul><li>如果你安装的是英文版，需要将时区改为上海。</li></ul><p><img src="/2019/12/29/shi-yong-vmware-an-zhuang-linux-xu-ni-ji/%E4%BD%BF%E7%94%A8VMware%E5%AE%89%E8%A3%85linux%E8%99%9A%E6%8B%9F%E6%9C%BA%5Cformat3.png" alt="img"><img src="/2019/12/29/shi-yong-vmware-an-zhuang-linux-xu-ni-ji/%E4%BD%BF%E7%94%A8VMware%E5%AE%89%E8%A3%85linux%E8%99%9A%E6%8B%9F%E6%9C%BA%5Cformat4.png" alt="img"><img src="/2019/12/29/shi-yong-vmware-an-zhuang-linux-xu-ni-ji/%E4%BD%BF%E7%94%A8VMware%E5%AE%89%E8%A3%85linux%E8%99%9A%E6%8B%9F%E6%9C%BA%5C20171126014938900.png" alt="img"></p><ul><li><strong>网络和主机名</strong></li></ul><p><img src="/2019/12/29/shi-yong-vmware-an-zhuang-linux-xu-ni-ji/%E4%BD%BF%E7%94%A8VMware%E5%AE%89%E8%A3%85linux%E8%99%9A%E6%8B%9F%E6%9C%BA%5C20171126015037602.png" alt="img"><img src="/2019/12/29/shi-yong-vmware-an-zhuang-linux-xu-ni-ji/%E4%BD%BF%E7%94%A8VMware%E5%AE%89%E8%A3%85linux%E8%99%9A%E6%8B%9F%E6%9C%BA%5C20171126015051216.png" alt="img"></p><ul><li>然后选择开始安装**</li></ul><p><img src="/2019/12/29/shi-yong-vmware-an-zhuang-linux-xu-ni-ji/%E4%BD%BF%E7%94%A8VMware%E5%AE%89%E8%A3%85linux%E8%99%9A%E6%8B%9F%E6%9C%BA%5Cformat7.png" alt="img">基本的系统就安装好了</p><h3 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h3><ul><li>linu有三种网络模式,分别是Host-Only、NAT、桥接。一般安装好以后会默认选择NAT。</li></ul><ul><li>进入之后修改ip地址信息</li></ul><pre><code>vi /etc/ sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0 #网卡名称HWADDR=08:00:27:8E:9D:25 #MAC地址TYPE=Ethernet #网络类型,这里是以太网UUID=5f2d815e-bd3b-4995-9009-823542e77304ONBOOT=yes NM_CONTROLLED=yesBOOTPROTO=staticSTATIC=trueIPADDR=192.168.1.21 #ip地址NETMASK=255.255.255.0 #子网掩码GATEWAY=192.168.1.1 #网管DNS1=202.202.0.33 #域名解析地址DNS2=114.114.114.114DNS3=8.8.8.8</code></pre><ul><li>配置好以后重启网络服务</li></ul><pre><code>services network restart</code></pre><ul><li>ifconfig查看IP地址</li></ul><pre><code>ifconfigeth0      Link encap:Ethernet  HWaddr 08:00:27:8E:9D:25            inet addr:192.168.1.21  Bcast:192.168.1.255  Mask:255.255.255.0          inet6 addr: fe80::a00:27ff:fe8e:9d25/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:1756623 errors:0 dropped:0 overruns:0 frame:0          TX packets:1952463 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:1445482120 (1.3 GiB)  TX bytes:1626059931 (1.5 GiB)lo        Link encap:Local Loopback            inet addr:127.0.0.1  Mask:255.0.0.0          inet6 addr: ::1/128 Scope:Host          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:2258 errors:0 dropped:0 overruns:0 frame:0          TX packets:2258 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0           RX bytes:590708 (576.8 KiB)  TX bytes:590708 (576.8 KiB)</code></pre><ul><li>ping ip地址测试网络是否配置好</li></ul><pre><code>ping www.baidu.com</code></pre><p><strong>按照以上操作完成安装以后可以直接克隆改虚拟机，然后修改配置就可以生成多台</strong></p><p><strong>在每个主机的/etc/hosts文件设置上每个主机的ip和名字的映射关系</strong></p><pre><code>vi /etc/hosts192.168.1.21 master192.168.1.23 slave1192.168.1.24 slave2192.168.1.25 slave3</code></pre><p><img src="/2019/12/29/shi-yong-vmware-an-zhuang-linux-xu-ni-ji/%E4%BD%BF%E7%94%A8VMware%E5%AE%89%E8%A3%85linux%E8%99%9A%E6%8B%9F%E6%9C%BA%5C1577691474359.png" alt="1577691474359"></p><h4 id="配置免密登录"><a href="#配置免密登录" class="headerlink" title="配置免密登录"></a>配置免密登录</h4><ul><li>主要用于两个机器之间相互登录不需要验证</li></ul><p>①在第一台机器使用命令ssh-keygen -t rsa生成私钥和秘钥</p><pre><code>ssh-keygen -t rsa</code></pre><p>②复制到另一台机器</p><pre><code>ssh-copy-id root@slave1</code></pre><p><strong>如此就可以实现slave登录master免密,按照这个做法,每两台机器都配置上。</strong></p><h5 id="科普：免密登录原理"><a href="#科普：免密登录原理" class="headerlink" title="科普：免密登录原理"></a>科普：免密登录原理</h5><p><img src="/2019/12/29/shi-yong-vmware-an-zhuang-linux-xu-ni-ji/%E4%BD%BF%E7%94%A8VMware%E5%AE%89%E8%A3%85linux%E8%99%9A%E6%8B%9F%E6%9C%BA%5C1577692561419.png" alt="1577692561419"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo博文包含图片的坑</title>
      <link href="/2019/12/29/hexo-bo-wen-bao-han-tu-pian-de-keng/"/>
      <url>/2019/12/29/hexo-bo-wen-bao-han-tu-pian-de-keng/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=414414&auto=0&height=66"></iframe></div><h1 id="hexo博文包含图片的坑"><a href="#hexo博文包含图片的坑" class="headerlink" title="hexo博文包含图片的坑"></a>hexo博文包含图片的坑</h1><h3 id="网上有很多关于这个的教程-主要的总结如下"><a href="#网上有很多关于这个的教程-主要的总结如下" class="headerlink" title="网上有很多关于这个的教程,主要的总结如下"></a>网上有很多关于这个的教程,主要的总结如下</h3><ul><li>①修改博客目录下的_config_yml的post_asset_folder为true</li></ul><pre class="line-numbers language-java"><code class="language-java">post_asset_folder<span class="token operator">:</span> <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>②安装hexo-asset-image插件</li></ul><pre><code>npm install hexo-asset-image --save</code></pre><ul><li>③hexo new  file_name 时会在source/_post/下生成file_name的文件夹,将需要使用的图片放置在里面,然后使用相对路径引入</li></ul><pre><code>![用于图片加载失败时显示的内容](/file_name/image_name)</code></pre><ul><li>如此博客中的图片最后会和.md文件一起生成到public\2019\12\27\file_name中,这样在hexe g 时,可以看到命令窗口会打印修改后的路径,如下</li></ul><pre><code>Start processingupdate link as:--&gt;/2019/12/27/first/1577523021175.pngupdate link as:--&gt;/2019/12/27/first/1577523021175.png</code></pre><h3 id="我遇到的问题"><a href="#我遇到的问题" class="headerlink" title="我遇到的问题"></a>我遇到的问题</h3><pre><code>Start processingupdate link as:--&gt;.io//2019/12/27/first/1577523021175.pngupdate link as:--&gt;.io//2019/12/27/first/1577523021175.png</code></pre><ul><li>经过一番搜寻,发现hexo-asset-image会将图片的地址修改,具体的源码信息可见\node_modules\hexo-asset-image\index.js,打开后内容如下:</li></ul><pre><code>&#39;use strict&#39;;var cheerio = require(&#39;cheerio&#39;);function getPosition(str, m, i) {  return str.split(m, i).join(m).length;}hexo.extend.filter.register(&#39;after_post_render&#39;, function(data){  var config = hexo.config;  if(config.post_asset_folder){    var link = data.permalink;    var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;    var appendLink = &#39;&#39;;    // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.    // if not with index.html endpos = link.lastIndexOf(&#39;.&#39;) + 1 support hexo-abbrlink    if(/.*\/index\.html$/.test(link)) {      // when permalink is end with index.html, for example 2019/02/20/xxtitle/index.html      // image in xxtitle/ will go to xxtitle/index/      appendLink = &#39;index/&#39;;      var endPos = link.lastIndexOf(&#39;/&#39;);    }    else {      var endPos = link.lastIndexOf(&#39;.&#39;) ;    }    link = link.substring(beginPos, endPos) + &#39;/&#39; + appendLink;    var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];    for(var i = 0; i &lt; toprocess.length; i++){      var key = toprocess[i];      var $ = cheerio.load(data[key], {        ignoreWhitespace: false,        xmlMode: false,        lowerCaseTags: false,        decodeEntities: false      });      $(&#39;img&#39;).each(function(){        if ($(this).attr(&#39;src&#39;)){          // For windows style path, we replace &#39;\&#39; to &#39;/&#39;.          var src = $(this).attr(&#39;src&#39;).replace(&#39;\\&#39;, &#39;/&#39;);          if(!(/http[s]*.*|\/\/.*/.test(src)            || /^\s+\//.test(src)            || /^\s*\/uploads|images\//.test(src))) {            // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.            // In addition, to support multi-level local directory.            var linkArray = link.split(&#39;/&#39;).filter(function(elem){              return elem != &#39;&#39;;            });            var srcArray = src.split(&#39;/&#39;).filter(function(elem){              return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;;            });            if(srcArray.length &gt; 1)            srcArray.shift();            src = srcArray.join(&#39;/&#39;);            $(this).attr(&#39;src&#39;, config.root + link + src);            console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);          }        }else{          console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);          console.info&amp;&amp;console.info($(this));        }      });      data[key] = $.html();    }  }});</code></pre><ul><li>通过查看源码发现里面有对生成博客图片的地址修改:</li></ul><pre><code>link = link.substring(beginPos, endPos) + &#39;/&#39; + appendLink;</code></pre><ul><li>通过排查发现图片的路径的endPos为:</li></ul><pre><code>var endPos = link.lastIndexOf(&#39;.&#39;) ;</code></pre><ul><li>我打印data.permalink得到</li></ul><pre><code>http://tigerLuHai.github.io/2019/12/27/first/</code></pre><p>如此在截取字符串的时候就会多出四个字符  <strong>.io/</strong></p><p>最后发现这段代码的作用就是要将data.permalink中路径的<a href="https://tigerLuhai.gituhub.io/去掉,因为在后面部署到github时使用相对路径访问会重新加上这个前缀,如果这里有就会重复,导致地址为https://tigerLuhai.gituhub.io/http://tigerLuHai.github.io/2019/12/27/first/的现象" target="_blank" rel="noopener">https://tigerLuhai.gituhub.io/去掉,因为在后面部署到github时使用相对路径访问会重新加上这个前缀,如果这里有就会重复,导致地址为https://tigerLuhai.gituhub.io/http://tigerLuHai.github.io/2019/12/27/first/的现象</a>.</p><p>明白了需求就可以修改代码为</p><pre><code>var endPos = link.lastIndexOf(&#39;/&#39;) ;</code></pre><p>这样就可以正常部署了.</p>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FastDFS分布式文件系统安装使用教程</title>
      <link href="/2019/12/28/fastdfs-fen-bu-shi-wen-jian-xi-tong-an-zhuang-shi-yong-jiao-cheng/"/>
      <url>/2019/12/28/fastdfs-fen-bu-shi-wen-jian-xi-tong-an-zhuang-shi-yong-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=479553545&auto=1&height=66"></iframe></div><h1 id="FastDFS分布式文件系统安装使用教程"><a href="#FastDFS分布式文件系统安装使用教程" class="headerlink" title="FastDFS分布式文件系统安装使用教程"></a>FastDFS分布式文件系统安装使用教程</h1><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>分布式文件系统用于<strong>海量</strong>文件存储及传输访问的瓶颈问题，对海量视频的管理、对<strong>海量</strong>图片的管理等,FastDFS与其他分布式文件系统相比的一个显著优点就是特别<strong>适合大量小文件(图片等)的存储,因为它在存储时没有对文件切片分割.</strong></p><h3 id="主流的分布式文件系统"><a href="#主流的分布式文件系统" class="headerlink" title="主流的分布式文件系统"></a>主流的分布式文件系统</h3><h4 id="①NFS"><a href="#①NFS" class="headerlink" title="①NFS"></a>①NFS</h4><p><img src="/2019/12/28/fastdfs-fen-bu-shi-wen-jian-xi-tong-an-zhuang-shi-yong-jiao-cheng/1577523021175.png" alt="1577523021175"></p><h4 id="②GFS"><a href="#②GFS" class="headerlink" title="②GFS"></a>②GFS</h4><p><img src="/2019/12/28/fastdfs-fen-bu-shi-wen-jian-xi-tong-an-zhuang-shi-yong-jiao-cheng/1577523108700.png" alt="1577523108700"></p><h4 id="③HDFS"><a href="#③HDFS" class="headerlink" title="③HDFS"></a>③HDFS</h4><p><img src="/2019/12/28/fastdfs-fen-bu-shi-wen-jian-xi-tong-an-zhuang-shi-yong-jiao-cheng/1577523192987.png" alt="1577523192987"></p><h4 id="④FastDFS"><a href="#④FastDFS" class="headerlink" title="④FastDFS"></a>④FastDFS</h4><p>FastDFS是用c语言编写的一款开源的分布式文件系统，它是由淘宝资深架构师余庆编写并开源。FastDFS专为互联 网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很 容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。</p><p><strong>FastDFS架构包括 Tracker server和Storageserver。客户端请求Tracker server进行文件上传、下载，通过Tracker server调度最终由Storage server完成文件上传和下载。</strong> </p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h4><ul><li>CentOS6.9(CenttOS安装过程一致)</li></ul><ul><li>IP: 192.168.1.21,192.168.1.23,192.168.1.24,192.168.1.25</li></ul><h4 id="安装Linux基本环境"><a href="#安装Linux基本环境" class="headerlink" title="安装Linux基本环境"></a>安装Linux基本环境</h4><p>参见Hadoop的安装使用教程中Linux环境搭建</p><h4 id="安装gcc环境-FastDFS是由c语言编写"><a href="#安装gcc环境-FastDFS是由c语言编写" class="headerlink" title="安装gcc环境(FastDFS是由c语言编写)"></a>安装gcc环境(FastDFS是由c语言编写)</h4><pre class="line-numbers language-linux"><code class="language-linux">yum install gcc-c++<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="安装-libevent"><a href="#安装-libevent" class="headerlink" title="安装 libevent"></a>安装 libevent</h4><pre class="line-numbers language-yum"><code class="language-yum">yum -y install libevent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="安装-libfastcommon"><a href="#安装-libfastcommon" class="headerlink" title="安装 libfastcommon"></a>安装 libfastcommon</h4><pre><code>将 libfastcommonV1.0.7.tar.gz 拷贝至/usr/local/下cd /usr/localtar -zxvf libfastcommonV1.0.7.tar.gzcd libfastcommon-1.0.7./make.sh./make.sh install</code></pre><p>注意：<strong>libfastcommon 安装好后会自动将库文件拷贝至/usr/lib64 下，由于 FastDFS 程序引用 usr/lib 目录所以需要将/usr/lib64 下的库文件拷贝至/usr/lib 下。</strong></p><p>需要拷贝的文件</p><p><img src="/2019/12/28/fastdfs-fen-bu-shi-wen-jian-xi-tong-an-zhuang-shi-yong-jiao-cheng/FastDFS%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%5C1577524769079.png" alt="1577524769079"></p><h4 id="tracker-编译安装"><a href="#tracker-编译安装" class="headerlink" title="tracker 编译安装"></a>tracker 编译安装</h4><pre class="line-numbers language-将"><code class="language-将">将 FastDFS_v5.05.tar.gz 拷贝至/usr/local/下tar -zxvf FastDFS_v5.05.tar.gzcd FastDFS./make.sh 编译./make.sh install 安装<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装成功将安装目录下的 conf 下的文件拷贝到/etc/fdfs/下。</p><pre><code>cp -r /usr/local/FastDFS/conf/ /etc/fdfs/</code></pre><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>安装成功后进入/etc/fdfs目录</p><p><img src="/2019/12/28/fastdfs-fen-bu-shi-wen-jian-xi-tong-an-zhuang-shi-yong-jiao-cheng/FastDFS%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%5C1577525471795.png" alt="1577525471795"></p><p>拷贝一份新的 tracker 配置文件：</p><pre><code>cp tracker.conf.sample tracker.conf</code></pre><p>修改 tracker.conf</p><pre><code>vi tracker.confbase_path=/home/yuqing/FastDFS #数据(日志等)存储路径,自己设置http.server_port=80 #配置 http 端口：</code></pre><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><pre><code>/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf start</code></pre><p>查看端口</p><pre><code>netstat -nltp</code></pre><p><img src="/2019/12/28/fastdfs-fen-bu-shi-wen-jian-xi-tong-an-zhuang-shi-yong-jiao-cheng/FastDFS%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%5C1577535905825.png" alt="1577535905825"></p><h4 id="storage-安装"><a href="#storage-安装" class="headerlink" title="storage 安装"></a>storage 安装</h4><ul><li>安装 libevent</li><li>安装 libfastcommon</li><li>编译安装(与tracker相同)</li></ul><h5 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h5><pre><code>vi storage.confgroup_name=group1 #分组,同一分组为设置冗余防止宕机不可用base_path=/home/yuqing/FastDFS #数据存储路径,自己设置store_path0=/home/yuqing/FastDFS #文件存储路径,自己设置tracker_server=192.168.101.3:22122 #配置 tracker 服务器:IPtracker_server=192.168.1.21:22122 #如果有多个则配置多个 trackerhttp.server_port=80</code></pre><h5 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h5><pre><code>/usr/bin/fdfs_storaged /etc/fdfs/storage.conf start</code></pre><h5 id="分发配置"><a href="#分发配置" class="headerlink" title="分发配置"></a>分发配置</h5><p>将FastDFS分发到各个节点,并修改配置,分发脚本如下</p><pre><code>#!/bin/bashpcount=$#if((pcount=0));thenecho no args;exit;fip1=$1fname=`basename $p1`echo fname=$fnamepdir=`cd -P $(dirname $p1);pwd`echo pdir=$pdiruser=`whoami`echo user=$userfor((host=1;host&lt;4;host++));doecho ------------salve$host-------------rsync -rvl $pdir/$fname $user@slave$host:$pdirdone</code></pre><h3 id="利用可通过-usr-bin-fdfs-test-程序测试"><a href="#利用可通过-usr-bin-fdfs-test-程序测试" class="headerlink" title="利用可通过/usr/bin/fdfs_test 程序测试"></a>利用可通过/usr/bin/fdfs_test 程序测试</h3><p>修改/etc/fdfs/client.conf</p><p>tracker_server 根据自己部署虚拟机的情况配置</p><pre><code>base_path = /home/yuqing/fastdfstracker-server=192.168.1.21:22122</code></pre><p>使用格式：</p><pre><code>/usr/bin/fdfs_test 客户端配置文件地址 upload 上传文件</code></pre><p>比如将/home 下的图片上传到 FastDFS 中：</p><pre><code>/usr/bin/fdfs_test /etc/fdfs/client.conf upload /home/tomcat.png</code></pre><p>打印日志如下:</p><pre><code>This is FastDFS client test program v5.05Copyright (C) 2008, Happy Fish / YuQingFastDFS may be copied only under the terms of the GNU GeneralPublic License V3, which may be found in the FastDFS source kit.Please visit the FastDFS Home Page http://www.csource.org/ for more detail.[2019-12-28 20:13:02] DEBUG - base_path=/home/fastdfs, connect_timeout=30, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0tracker_query_storage_store_list_without_group:         server 1. group_name=, ip_addr=192.168.1.24, port=23000group_name=group1, ip_addr=192.168.1.24, port=23000storage_upload_by_filenamegroup_name=group1, remote_filename=M00/00/00/wKgBGF4HRs6AOwJJAAId77F78II587.pngsource ip address: 192.168.1.24file timestamp=2019-12-28 20:13:02file size=138735file crc32=2977689730example file url: http://192.168.1.24/group1/M00/00/00/wKgBGF4HRs6AOwJJAAId77F78II587.pngstorage_upload_slave_by_filenamegroup_name=group1, remote_filename=M00/00/00/wKgBGF4HRs6AOwJJAAId77F78II587_big.pngsource ip address: 192.168.1.24file timestamp=2019-12-28 20:13:02file size=138735file crc32=2977689730</code></pre><p><a href="http://192.168.1.24/group1/M00/00/00/wKgBGF4HRs6AOwJJAAId77F78II587.png" target="_blank" rel="noopener">http://192.168.1.24/group1/M00/00/00/wKgBGF4HRs6AOwJJAAId77F78II587.png</a><br>就是文件的下载路径。对应服务器的base_path/fdfs_storage/data/00/00/wKgBGF4HRs6AOwJJAAId77F78II587.png文件</p><p>现在还没有和 nginx 整合无法使用 http 下载。</p><h3 id="Nginx整合FastDFS"><a href="#Nginx整合FastDFS" class="headerlink" title="Nginx整合FastDFS"></a>Nginx整合FastDFS</h3><h4 id="FastDFS-nginx-module"><a href="#FastDFS-nginx-module" class="headerlink" title="FastDFS-nginx-module"></a>FastDFS-nginx-module</h4><p>将 FastDFS-nginx-module_v1.16.tar.gz 传 至 fastDFS 的 storage 服 务 器 的</p><p>/usr/local/下，执行如下命令：</p><pre><code>cd /usr/localtar -zxvf FastDFS-nginx-module_v1.16.tar.gzcd FastDFS-nginx-module/srcvi config</code></pre><p><img src="/2019/12/28/fastdfs-fen-bu-shi-wen-jian-xi-tong-an-zhuang-shi-yong-jiao-cheng/FastDFS%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%5C1577536510714.png" alt="1577536510714"></p><p>将/usr/local修改为/usr，注意这里有三场，不要改漏了。</p><p>将 FastDFS-nginx-module/src 下的 mod_FastDFS.conf 拷贝至/etc/fdfs/下</p><pre><code>cp mod_FastDFS.conf /etc/fdfs/vi /etc/fdfs/mod_FastDFS.confbase_path=/home/FastDFS # 保持和之前安装时一致tracker_server=192.168.1.21:22122url_have_group_name=true #url 中包含 group 名称store_path0=/home/fastdfs/fdfs_storage #指定文件存储路径,和之前一致</code></pre><p>将 libfdfsclient.so 拷贝至/usr/lib 下</p><pre><code>cp /usr/lib64/libfdfsclient.so /usr/lib/</code></pre><p>创建 nginx/client 目录</p><pre><code>mkdir -p /var/temp/nginx/client</code></pre><h4 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h4><p>详细教程可见nginx使用感悟</p><p>将 nginx-1.8.0.tar.gz 拷贝到/usr/local 下</p><p>解压 nginx-1.8.0.tar.gz</p><p>进入 nginx-1.8.0 目录，执行如下配置命令：</p><pre><code>./configure --add-module=/usr/local/FastDFS-nginx-module/srcmake make install</code></pre><p>在nginx中增加如下虚拟机配置:</p><p>storage配置:</p><pre><code>server { listen 80; server_name 192.168.1.23; 本机ip location /group1/M00/{ root /home/FastDFS/fdfs_storage/data;  #以自己配置的地址为准 ngx_FastDFS_module; } }</code></pre><p>tracker配置:</p><pre><code>#storage 群 group1 组upstream storage_server_group1{ server 192.168.1.23:80 weight=10;server 192.168.1.24:80 weight=10; } #storage 群 group2 组upstream storage_server_group2{ server 192.168.1.25:80 weight=10; } server {listen 80;server_name ccc.test.com;location /group1{proxy_redirect off;proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_pass http://storage_server_group1;}location /group2{proxy_redirect off;proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_pass http://storage_server_group2; } }</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>使用浏览器 http 访问文件，这里访问上传图片测试的文件：</p><p>访问 storage：<a href="http://192.168.1.24/group1/M00/00/00/wKgBGF4HRs6AOwJJAAId77F78II587.png" target="_blank" rel="noopener">http://192.168.1.24/group1/M00/00/00/wKgBGF4HRs6AOwJJAAId77F78II587.png</a></p><p><img src="/2019/12/28/fastdfs-fen-bu-shi-wen-jian-xi-tong-an-zhuang-shi-yong-jiao-cheng/FastDFS%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%5C1577537632508.png" alt="1577537632508"></p><p>ip 地址改为 192.168.1.24也可以访问到文件，因为同一个分组的 storage 文件互相同步。</p><h3 id="编写java代码上传下载文件"><a href="#编写java代码上传下载文件" class="headerlink" title="编写java代码上传下载文件"></a>编写java代码上传下载文件</h3><p><strong>SpringBoot测试方案</strong></p><p>引入依赖</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;net.oschina.zcx7878&lt;/groupId&gt;            &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt;            &lt;version&gt;1.27.0.0&lt;/version&gt;        &lt;/dependency&gt;</code></pre><pre><code>@SpringBootTest@RunWith(SpringRunner.class)public class TestFastDFS {    @Test    public void upload() throws IOException, MyException {        //加载fastdfs-client.properties配置文件        ClientGlobal.initByProperties(&quot;config/fastdfs-client.properties&quot;);        //定义TrackerClient,用于请求TrackerClient        TrackerClient trackerClient = new TrackerClient();        //创建TrackerServer        TrackerServer trackerServer = trackerClient.getConnection();        //通过TrackerServer获取storeServer        StorageServer storeServer = trackerClient.getStoreStorage(trackerServer);        //通过TrackerServer and storeServer 创建storageClient1        StorageClient1 storageClient1 = new StorageClient1(trackerServer, storeServer);        //fileId group1/M00/00/00/wKgBF13ebJuALXhqAAI6t5YoKLQ94..log        String fileId = storageClient1.upload_file1(&quot;C:\\Users\\tiger\\Pictures\\Feedback\\{A687785D-19C3-4B2E-A00A-2667141271EB}\\Capture001.png&quot;, &quot;.png&quot;, null);        System.out.println(fileId);        //获取tracker客户端    }    @Test    public void download() throws IOException, MyException {        //加载fastdfs-client.properties配置文件        ClientGlobal.initByProperties(&quot;config/fastdfs-client.properties&quot;);        //定义TrackerClient,用于请求TrackerClient        TrackerClient trackerClient = new TrackerClient();        //创建TrackerServer        TrackerServer trackerServer = trackerClient.getConnection();        //通过TrackerServer获取storeServer        StorageServer storeServer = trackerClient.getStoreStorage(trackerServer);        //通过TrackerServer and storeServer 创建storageClient1        StorageClient1 storageClient1 = new StorageClient1(trackerServer, storeServer);        //fileId group1/M00/00/00/wKgBF13ebJuALXhqAAI6t5YoKLQ94..log        byte[] bytes = storageClient1.download_file1(&quot;group1/M00/00/00/wKgBF13ebJuALXhqAAI6t5YoKLQ94..log&quot;);        FileOutputStream fos = new FileOutputStream(new File(&quot;hello&quot;));        fos.write(bytes);    }}</code></pre><p>config/fastdfs-client.properties</p><pre><code>fastdfs.connect_timeout_in_seconds = 5fastdfs.network_timeout_in_seconds = 30fastdfs.charset = UTF-8fastdfs.tracker_servers = 192.168.1.21:22122</code></pre><p>运行upload得到路径</p><pre><code>group1/M00/00/00/wKgBGF4HUZiAOKLgAB7xNcvo_Vw00..png根据自己配置的路径可以得到访问的http协议路径为:http://192.168.1.21/group1/M00/00/00/wKgBGF4HUZiAOKLgAB7xNcvo_Vw00..png</code></pre><p>效果如下</p><p><img src="/2019/12/28/fastdfs-fen-bu-shi-wen-jian-xi-tong-an-zhuang-shi-yong-jiao-cheng/FastDFS%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%5C1577538377340.png" alt="1577538377340"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>FastDFS相对于HDFS等分布式文件的优势在于它不切分文件,所以下载文件的时候没有拼装文件的过程,而且可以锁定一台机器进行网络I/O,所以速度很快.不过正所谓这也是它的缺点,这导致它不能用于存储大文件.所以FastDFS适合存储大量图片小视频之类的文件.</strong></p><h3 id="安装过程遇到的一些问题"><a href="#安装过程遇到的一些问题" class="headerlink" title="安装过程遇到的一些问题"></a>安装过程遇到的一些问题</h3><p>①安装nginx No rule to make target “/usr/local/fastdfs-nginx-module/src/ngx_http_fastdfs_module.c”, needed by objs/addon/src/ngx_http_fastdfs_module.o . Stop. 修改fastdfs-nginx-module/src/config文件中的路径,删除local(注意一共有三个)</p><p>②nginx安装cp: <code>conf/koi-win&#39; and</code>/usr/local/nginx/conf/koi-win’ are the same file 解决 将./configure –prefix=/usr/local/nginx 改为 ./configure –prefix=/usr/local/nginx –conf-path=/usr/local/nginx/nginx.conf</p><p>③nginx编码严格.直接复制会出现nginx: [emerg] unknown directive “ “ in /usr/local/nginx-1.12.0-storage/conf/nginx.conf:49）：所以需要手动输入nginx.conf</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>first</title>
      <link href="/2019/12/27/first/"/>
      <url>/2019/12/27/first/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/12/27/first/1577523021175.png" alt="1577523021175"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop集群搭建与简单使用</title>
      <link href="/2019/12/01/hadoop-ji-qun-da-jian-yu-jian-dan-shi-yong/"/>
      <url>/2019/12/01/hadoop-ji-qun-da-jian-yu-jian-dan-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Hadoop集群搭建与简单使用"><a href="#Hadoop集群搭建与简单使用" class="headerlink" title="Hadoop集群搭建与简单使用"></a>Hadoop集群搭建与简单使用</h1><p>首先需要搭建一个linux的集群,可以参见我的博客<a href="https://tigerluhai.github.io/2019/12/29/shi-yong-vmware-an-zhuang-linux-xu-ni-ji/">linux集群搭建</a></p><blockquote><p>Hadoop的运行是基于java的,所以需要先安装JDK,而且JDK版本必须高于1.7</p></blockquote><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><p>（1）查询是否安装Java软件：</p><pre><code> rpm -qa | grep java</code></pre><p>（2）如果安装的版本低于1.7，卸载该JDK：</p><pre><code>sudo rpm -e 软件包</code></pre><p>（3）查看JDK安装路径：</p><pre><code> which(or whereis) java</code></pre><p>（4）解压JDK：</p><pre><code>tar -zxvf 安装包名 -C 目标路径</code></pre><p>（5）配置JDK环境：</p><pre><code>vi /etc/profile在文件末尾加上#JAVA_HOMEexport JAVA_HOME=/opt/module/jdk1.8.0_144export PATH=$PATH:$JAVA_HOME/bin</code></pre><p><strong>修改后需要立即生效需要运行如下命令:</strong></p><pre><code>source /etc/profile</code></pre><p>（6）测试JDK安装是否成功：</p><pre><code>java -version</code></pre><h3 id="安装Hadoop"><a href="#安装Hadoop" class="headerlink" title="安装Hadoop"></a>安装Hadoop</h3><p>（1）解压hadoop安装包到指定位置</p><pre><code>tar -zxvf 安装包 -C 指定目录</code></pre><p>（2）添加环境变量</p><pre><code>vi /etc/profile在文件末尾加上#HADOOP_HOMEexport HADOOP_HOME=/opt/module/hadoop-3.1.2export PATH=$PATH:$HADOOP_HOME/binexport PATH=$PATH:$HADOOP_HOME/sbin</code></pre><p>(3)修改配置文件</p><ul><li>集群部署规划</li></ul><table><thead><tr><th></th><th>master</th><th>slave1</th><th>slave2</th><th>slave3</th></tr></thead><tbody><tr><td>HDFS</td><td>NameNodeDataNode</td><td>SecondaryNameNode DataNode</td><td>DataNode</td><td>DataNode</td></tr><tr><td>YARN</td><td>NodeManager</td><td>ResourceManager</td><td>NodeManager</td><td>NodeManager</td></tr></tbody></table><ul><li>核心配置文件</li></ul><p>配置core-site.xml</p><pre><code>vi core-site.xml# 在该文件中编写如下配置&lt;!-- 指定HDFS中NameNode的地址 --&gt;&lt;property&gt;    &lt;name&gt;fs.defaultFS&lt;/name&gt;    &lt;value&gt;hdfs://master:9000&lt;/value&gt;&lt;/property&gt;&lt;!-- 指定Hadoop运行时产生文件的存储目录 --&gt;&lt;property&gt;    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;    &lt;value&gt;/opt/module/hadoop-3.1.2/data/tmp&lt;/value&gt;&lt;/property&gt;</code></pre><ul><li>HDFS配置文件</li></ul><p>配置hadoop-env.sh</p><pre><code> vi hadoop-env.shexport JAVA_HOME=/opt/module/jdk1.8.0_144</code></pre><p>配置hdfs-site.xml</p><pre><code>vi hdfs-site.xml&lt;!--配置副本数量--&gt;&lt;property&gt;        &lt;name&gt;dfs.replication&lt;/name&gt;        &lt;value&gt;3&lt;/value&gt;&lt;/property&gt;&lt;!-- 指定Hadoop辅助名称节点主机配置 --&gt;&lt;property&gt;      &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;      &lt;value&gt;slave1:50090&lt;/value&gt;&lt;/property&gt;</code></pre><p>注意:文件副本数量不只是dfs.replication决定,而是min(datanode节点数,dfs.replication)</p><ul><li>YARN配置文件</li></ul><p>配置yarn-env.sh</p><pre><code> vi yarn-env.shexport JAVA_HOME=/opt/module/jdk1.8.0_144</code></pre><ul><li>配置yarn-site.xml</li></ul><pre><code> vi yarn-site.xml&lt;!-- Reducer获取数据的方式 --&gt;&lt;property&gt;    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;&lt;!-- 指定YARN的ResourceManager的地址 --&gt;&lt;property&gt;    &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;    &lt;value&gt;slave2&lt;/value&gt;&lt;/property&gt;</code></pre><ul><li>MapReduce配置文件</li></ul><pre><code>vi mapred-env.shexport JAVA_HOME=/opt/module/jdk1.8.0_144</code></pre><p><strong>注意：hadoop3之前的版本,mapreduce会继承hadoop的配置,所以可以不用配置这一项,但是3以后的版本必须配置,否则运行mapreduce时会报环境出错。</strong></p><ul><li>配置mapred-site.xml</li></ul><pre><code>cp mapred-site.xml.template mapred-site.xmlvi mapred-site.xml&lt;!-- 指定MR运行在Yarn上 --&gt;&lt;property&gt;        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;        &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt;</code></pre><p>（4）在集群上分发配置好的Hadoop配置文件</p><p>编写分发脚本</p><pre><code>vi /usr/local/bin/xsync#!/bin/bashpcount=$#if((pcount=0));thenecho no args;exit;fip1=$1fname=`basename $p1`echo fname=$fnamepdir=`cd -P $(dirname $p1);pwd`echo pdir=$pdiruser=`whoami`echo user=$userfor((host=1;host&lt;4;host++));doecho ------------salve$host-------------rsync -rvl $pdir/$fname $user@slave$host:$pdirdone</code></pre><pre><code>xsync /opt/module/hadoop-3.1.2/</code></pre><h3 id="集群单节点启动"><a href="#集群单节点启动" class="headerlink" title="集群单节点启动"></a>集群单节点启动</h3><p>（1）如果集群是第一次启动，需要<strong>格式化NameNode</strong></p><pre><code>hadoop namenode -format</code></pre><p>（2）在master上启动NameNode</p><pre><code>hadoop-daemon.sh start namenode</code></pre><p>查看节点启动状态</p><pre><code> jps</code></pre><p><strong>注意:jps用于查看java进程,namenode和datanode都是java进程</strong></p><p>（3）在master,slave1,slave2以及slave3上分别启动DataNode</p><pre><code>hadoop-daemon.sh start datanode</code></pre><pre><code> jps3461 NameNode3608 Jps3561 DataNode</code></pre><p>思考：每次都一个一个节点启动，如果节点数太多怎么办？</p><h3 id="群起集群"><a href="#群起集群" class="headerlink" title="群起集群"></a>群起集群</h3><ol><li>配置slaves</li></ol><pre><code>vi /opt/module/hadoop-3.1.2/etc/hadoop/slaves在该文件中增加如下内容：masterslave1slave2slave3</code></pre><p><strong>注意：该文件中添加的内容结尾不允许有空格，文件中不允许有空行。</strong></p><p>同步所有节点配置文件</p><pre><code> xsync slaves</code></pre><ol start="2"><li>启动集群</li></ol><p>（1）如果集群是第一次启动，需要格式化NameNode（注意格式化之前，一定要先停止上次启动的所有namenode和datanode进程，然后再删除data和log数据）</p><pre><code>hdfs namenode -format</code></pre><p>（2）启动HDFS</p><pre><code>start-dfs.sh</code></pre><p>（3）启动YARN</p><pre><code>start-yarn.sh</code></pre><p><strong>注意：NameNode和ResourceManger如果不是同一台机器，不能在NameNode上启动 YARN，应该在ResouceManager所在的机器上启动YARN。</strong></p><h3 id="集群基本操作"><a href="#集群基本操作" class="headerlink" title="集群基本操作"></a>集群基本操作</h3><ul><li>-ls: 显示目录信息</li></ul><pre><code>hadoop fs -ls /</code></pre><ul><li>mkdir：在HDFS上创建目录</li></ul><pre><code> hadoop fs -mkdir -p /parent/test</code></pre><ul><li>moveFromLocal：从本地剪切粘贴到HDFS</li></ul><pre><code>hadoop fs  -moveFromLocal  ./kongming.txt  /parent/test</code></pre><ul><li>appendToFile：追加一个文件到已经存在的文件末尾</li></ul><pre><code> hadoop fs -appendToFile liubei.txt /parent/test/kongming.txt</code></pre><ul><li>cat：显示文件内容</li></ul><pre><code>hadoop fs -cat /parent/test/kongming.txt</code></pre><ul><li>chgrp 、-chmod、-chown：Linux文件系统中的用法一样，修改文件所属权限</li><li>copyFromLocal：从本地文件系统中拷贝文件到HDFS路径去</li></ul><pre><code> hadoop fs -copyFromLocal README.txt /</code></pre><ul><li>copyToLocal：从HDFS拷贝到本地</li></ul><pre><code> hadoop fs -copyToLocal /parent/test/kongming.txt ./</code></pre><ul><li>cp ：从HDFS的一个路径拷贝到HDFS的另一个路径</li></ul><pre><code>hadoop fs -cp /parent/test/kongming.txt  /zhuge.txt</code></pre><ul><li>mv：在HDFS目录中移动文件</li></ul><pre><code>hadoop fs -mv /zhuge.txt /parent/test/</code></pre><ul><li>get：等同于copyToLocal，就是从HDFS下载文件到本地</li></ul><pre><code>hadoop fs -get /parent/test/kongming.txt ./</code></pre><ul><li>getmerge：合并下载多个文件，比如HDFS的目录 /parent/test//test下有多个文件:log.1, log.2,log.3,…</li></ul><pre><code>hadoop fs -getmerge /parent/test/test/* ./zaiyiqi.txt</code></pre><ul><li>put：等同于copyFromLocal</li></ul><pre><code> hadoop fs -put ./zaiyiqi.txt /</code></pre><ul><li>tail：显示一个文件的末尾</li></ul><ul><li>rm：删除文件或文件夹</li></ul><ul><li>rmdir：删除空目录</li></ul><ul><li>du统计文件夹的大小信息</li></ul><h3 id="JAVA代码操作HDFS"><a href="#JAVA代码操作HDFS" class="headerlink" title="JAVA代码操作HDFS"></a>JAVA代码操作HDFS</h3><pre><code>    Logger logger = LoggerFactory.getLogger(HdfsClient.class);    FileSystem fileSystem;    Configuration configuration;    @Test    /**     * 测试环境正常     */    public void HDFS_ENV() throws IOException {        Logger logger = LoggerFactory.getLogger(HdfsClient.class);        //1.获取hdfs客户端对象        Configuration configuration = new Configuration();        configuration.set(&quot;fs.defaultFS&quot;,&quot;hdfs://master:9000&quot;);        FileSystem fileSystem = FileSystem.get(configuration);        //2.在hdfs上执行相关操作        boolean mkdirs = fileSystem.mkdirs(new Path(&quot;/client_test_environment&quot;));        //3.关闭资源        fileSystem.close();        System.out.println(mkdirs);    }    @Before    /**     * 创建fileSystem对象     */    public void createFileSystem() throws URISyntaxException, IOException, InterruptedException {        //1.获取fs对象        configuration = new Configuration();        fileSystem = FileSystem.get(new URI(&quot;hdfs://master:9000&quot;), configuration, &quot;root&quot;);    }    @Test    public void copyFromLocalFile() throws IOException{        //执行上传操作        fileSystem.copyFromLocalFile(new Path(&quot;D:\\logs\\xc.2019-04-29.log&quot;),new Path(&quot;/client_test_environment/&quot;));        //关闭资源        fileSystem.close();    }    @Test    public void copyToLocalFile() throws IOException{        //执行上传操作        fileSystem.copyToLocalFile(true,new Path(&quot;/client_test_environment/xc.2019-04-29.log&quot;),new Path(&quot;D:\\logs\\xc.2019-04-29-back.log&quot;),false);        //关闭资源        fileSystem.close();    }    @Test    public void listFiles() throws IOException {        //查看文件信息        RemoteIterator&lt;LocatedFileStatus&gt; iterator = fileSystem.listFiles(new Path(&quot;/&quot;), true);        while (iterator.hasNext()){            LocatedFileStatus fileStatus = iterator.next();            //获取文件名称，文件权限，文件长度，块信息            logger.info(fileStatus.getPath().getName());            logger.info(fileStatus.getLen()+&quot;&quot;);            logger.info(fileStatus.getPermission()+&quot;&quot;);            BlockLocation[] blockLocations = fileStatus.getBlockLocations();            for (BlockLocation blockLocation : blockLocations) {                logger.info(blockLocation.toString());            }            logger.info(&quot;----------------                    ----------------------&quot;);        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
